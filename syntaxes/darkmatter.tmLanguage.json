{
    "version": "0.1.0",
    "name": "Darkmatter",
    "scopeName": "source.dm",
    "patterns": [
        {
            "include": "#preprocessor"
        },
        {
            "include": "#comment"
        },
        {
            "include": "#directives"
        },
        {
            "include": "#declarations"
        },
        {
            "include": "#script-top-level"
        }
    ],
    "repository": {
        "directives": {
            "patterns": [
                {
                    "include": "#extern-alias-directive"
                },
                {
                    "include": "#using-directive"
                },
                {
                    "include": "#attribute-section"
                },
                {
                    "include": "#punctuation-semicolon"
                }
            ]
        },
        "declarations": {
            "patterns": [
                {
                    "include": "#namespace-declaration"
                },
                {
                    "include": "#type-declarations"
                },
                {
                    "include": "#punctuation-semicolon"
                }
            ]
        },
        "script-top-level": {
            "patterns": [
                {
                    "include": "#statement"
                },
                {
                    "include": "#method-declaration"
                },
                {
                    "include": "#punctuation-semicolon"
                }
            ]
        },
        "type-declarations": {
            "patterns": [
                {
                    "include": "#preprocessor"
                },
                {
                    "include": "#comment"
                },
                {
                    "include": "#storage-modifier"
                },
                {
                    "include": "#class-declaration"
                },
                {
                    "include": "#delegate-declaration"
                },
                {
                    "include": "#enum-declaration"
                },
                {
                    "include": "#interface-declaration"
                },
                {
                    "include": "#struct-declaration"
                },
                {
                    "include": "#record-declaration"
                },
                {
                    "include": "#attribute-section"
                },
                {
                    "include": "#punctuation-semicolon"
                }
            ]
        },
        "class-or-struct-members": {
            "patterns": [
                {
                    "include": "#preprocessor"
                },
                {
                    "include": "#comment"
                },
                {
                    "include": "#storage-modifier"
                },
                {
                    "include": "#type-declarations"
                },
                {
                    "include": "#property-declaration"
                },
                {
                    "include": "#field-declaration"
                },
                {
                    "include": "#event-declaration"
                },
                {
                    "include": "#indexer-declaration"
                },
                {
                    "include": "#variable-initializer"
                },
                {
                    "include": "#constructor-declaration"
                },
                {
                    "include": "#destructor-declaration"
                },
                {
                    "include": "#operator-declaration"
                },
                {
                    "include": "#conversion-operator-declaration"
                },
                {
                    "include": "#method-declaration"
                },
                {
                    "include": "#attribute-section"
                },
                {
                    "include": "#punctuation-semicolon"
                }
            ]
        },
        "interface-members": {
            "patterns": [
                {
                    "include": "#preprocessor"
                },
                {
                    "include": "#comment"
                },
                {
                    "include": "#property-declaration"
                },
                {
                    "include": "#event-declaration"
                },
                {
                    "include": "#indexer-declaration"
                },
                {
                    "include": "#method-declaration"
                },
                {
                    "include": "#attribute-section"
                },
                {
                    "include": "#punctuation-semicolon"
                }
            ]
        },
        "statement": {
            "patterns": [
                {
                    "include": "#preprocessor"
                },
                {
                    "include": "#comment"
                },
                {
                    "include": "#while-statement"
                },
                {
                    "include": "#do-statement"
                },
                {
                    "include": "#for-statement"
                },
                {
                    "include": "#foreach-statement"
                },
                {
                    "include": "#if-statement"
                },
                {
                    "include": "#else-part"
                },
                {
                    "include": "#goto-statement"
                },
                {
                    "include": "#return-statement"
                },
                {
                    "include": "#break-or-continue-statement"
                },
                {
                    "include": "#throw-statement"
                },
                {
                    "include": "#yield-statement"
                },
                {
                    "include": "#await-statement"
                },
                {
                    "include": "#try-statement"
                },
                {
                    "include": "#checked-unchecked-statement"
                },
                {
                    "include": "#context-control-statement"
                },
                {
                    "include": "#context-control-paren-statement"
                },
                {
                    "include": "#labeled-statement"
                },
                {
                    "include": "#object-creation-expression"
                },
                {
                    "include": "#array-creation-expression"
                },
                {
                    "include": "#anonymous-object-creation-expression"
                },
                {
                    "include": "#local-declaration"
                },
                {
                    "include": "#block"
                },
                {
                    "include": "#expression"
                },
                {
                    "include": "#punctuation-semicolon"
                }
            ]
        },
        "expression": {
            "patterns": [
                {
                    "include": "#preprocessor"
                },
                {
                    "include": "#comment"
                },
                {
                    "include": "#expression-operator-expression"
                },
                {
                    "include": "#type-operator-expression"
                },
                {
                    "include": "#default-literal-expression"
                },
                {
                    "include": "#throw-expression"
                },
                {
                    "include": "#raw-interpolated-string"
                },
                {
                    "include": "#interpolated-string"
                },
                {
                    "include": "#verbatim-interpolated-string"
                },
                {
                    "include": "#type-builtin"
                },
                {
                    "include": "#language-variable"
                },
                {
                    "include": "#switch-statement-or-expression"
                },
                {
                    "include": "#with-expression"
                },
                {
                    "include": "#conditional-operator"
                },
                {
                    "include": "#assignment-expression"
                },
                {
                    "include": "#expression-operators"
                },
                {
                    "include": "#await-expression"
                },
                {
                    "include": "#query-expression"
                },
                {
                    "include": "#as-expression"
                },
                {
                    "include": "#is-expression"
                },
                {
                    "include": "#anonymous-method-expression"
                },
                {
                    "include": "#object-creation-expression"
                },
                {
                    "include": "#array-creation-expression"
                },
                {
                    "include": "#anonymous-object-creation-expression"
                },
                {
                    "include": "#invocation-expression"
                },
                {
                    "include": "#member-access-expression"
                },
                {
                    "include": "#element-access-expression"
                },
                {
                    "include": "#cast-expression"
                },
                {
                    "include": "#literal"
                },
                {
                    "include": "#parenthesized-expression"
                },
                {
                    "include": "#tuple-deconstruction-assignment"
                },
                {
                    "include": "#initializer-expression"
                },
                {
                    "include": "#identifier"
                }
            ]
        },
        "extern-alias-directive": {
            "begin": "\\b(extern)\\s+(alias)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.other.directive.extern.dm"
                },
                "2": {
                    "name": "keyword.other.directive.alias.dm"
                }
            },
            "end": "(?=;)",
            "patterns": [
                {
                    "match": "\\@?[_[:alpha:]][_[:alnum:]]*",
                    "name": "variable.other.alias.dm"
                }
            ]
        },
        "using-directive": {
            "patterns": [
                {
                    "begin": "\\b(?:(global)\\s+)?(using)\\s+(static)\\b\\s*(?:(unsafe)\\b\\s*)?",
                    "beginCaptures": {
                        "1": {
                            "name": "keyword.other.directive.global.dm"
                        },
                        "2": {
                            "name": "keyword.other.directive.using.dm"
                        },
                        "3": {
                            "name": "keyword.other.directive.static.dm"
                        },
                        "4": {
                            "name": "storage.modifier.unsafe.dm"
                        }
                    },
                    "end": "(?=;)",
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                },
                {
                    "begin": "\\b(?:(global)\\s+)?(using)\\b\\s*(?:(unsafe)\\b\\s*)?(@?[_[:alpha:]][_[:alnum:]]*)\\s*(=)",
                    "beginCaptures": {
                        "1": {
                            "name": "keyword.other.directive.global.dm"
                        },
                        "2": {
                            "name": "keyword.other.directive.using.dm"
                        },
                        "3": {
                            "name": "storage.modifier.unsafe.dm"
                        },
                        "4": {
                            "name": "entity.name.type.alias.dm"
                        },
                        "5": {
                            "name": "keyword.operator.assignment.dm"
                        }
                    },
                    "end": "(?=;)",
                    "patterns": [
                        {
                            "include": "#comment"
                        },
                        {
                            "include": "#type"
                        }
                    ]
                },
                {
                    "begin": "\\b(?:(global)\\s+)?(using)\\b\\s*+(?!\\(|var\\b)",
                    "beginCaptures": {
                        "1": {
                            "name": "keyword.other.directive.global.dm"
                        },
                        "2": {
                            "name": "keyword.other.directive.using.dm"
                        }
                    },
                    "end": "(?=;)",
                    "patterns": [
                        {
                            "include": "#comment"
                        },
                        {
                            "name": "entity.name.type.namespace.dm",
                            "match": "\\@?[_[:alpha:]][_[:alnum:]]*"
                        },
                        {
                            "include": "#punctuation-accessor"
                        },
                        {
                            "include": "#operator-assignment"
                        }
                    ]
                }
            ]
        },
        "attribute-section": {
            "begin": "(\\[)(assembly|module|field|event|method|param|property|return|type)?(\\:)?",
            "beginCaptures": {
                "1": {
                    "name": "punctuation.squarebracket.open.dm"
                },
                "2": {
                    "name": "keyword.other.attribute-specifier.dm"
                },
                "3": {
                    "name": "punctuation.separator.colon.dm"
                }
            },
            "end": "(\\])",
            "endCaptures": {
                "1": {
                    "name": "punctuation.squarebracket.close.dm"
                }
            },
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#attribute"
                },
                {
                    "include": "#punctuation-comma"
                }
            ]
        },
        "attribute": {
            "patterns": [
                {
                    "include": "#type-name"
                },
                {
                    "include": "#attribute-arguments"
                }
            ]
        },
        "attribute-arguments": {
            "begin": "(\\()",
            "beginCaptures": {
                "1": {
                    "name": "punctuation.parenthesis.open.dm"
                }
            },
            "end": "(\\))",
            "endCaptures": {
                "1": {
                    "name": "punctuation.parenthesis.close.dm"
                }
            },
            "patterns": [
                {
                    "include": "#attribute-named-argument"
                },
                {
                    "include": "#expression"
                },
                {
                    "include": "#punctuation-comma"
                }
            ]
        },
        "attribute-named-argument": {
            "begin": "(@?[_[:alpha:]][_[:alnum:]]*)\\s*(?==)",
            "beginCaptures": {
                "1": {
                    "name": "entity.name.variable.property.dm"
                }
            },
            "end": "(?=(,|\\)))",
            "patterns": [
                {
                    "include": "#operator-assignment"
                },
                {
                    "include": "#expression"
                }
            ]
        },
        "namespace-declaration": {
            "begin": "\\b(namespace)\\s+",
            "beginCaptures": {
                "1": {
                    "name": "storage.type.namespace.dm"
                }
            },
            "end": "(?<=\\})|(?=;)",
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "name": "entity.name.type.namespace.dm",
                    "match": "@?[_[:alpha:]][_[:alnum:]]*"
                },
                {
                    "include": "#punctuation-accessor"
                },
                {
                    "begin": "\\{",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.open.dm"
                        }
                    },
                    "end": "\\}",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#declarations"
                        },
                        {
                            "include": "#using-directive"
                        },
                        {
                            "include": "#punctuation-semicolon"
                        }
                    ]
                }
            ]
        },
        "storage-modifier": {
            "name": "storage.modifier.$1.dm",
            "match": "(?<!\\.)\\b(new|public|protected|internal|private|abstract|virtual|override|sealed|static|partial|readonly|volatile|const|extern|async|unsafe|ref|required|file)\\b"
        },
        "class-declaration": {
            "begin": "(?=(\\brecord\\b\\s+)?\\bclass\\b)",
            "end": "(?<=\\})|(?=;)",
            "patterns": [
                {
                    "begin": "(?x)\n(\\b(record)\\b\\s+)?\n\\b(class)\\b\\s+\n(@?[_[:alpha:]][_[:alnum:]]*)\\s*",
                    "beginCaptures": {
                        "2": {
                            "name": "storage.type.record.dm"
                        },
                        "3": {
                            "name": "storage.type.class.dm"
                        },
                        "4": {
                            "name": "entity.name.type.class.dm"
                        }
                    },
                    "end": "(?=\\{)|(?=;)",
                    "patterns": [
                        {
                            "include": "#comment"
                        },
                        {
                            "include": "#type-parameter-list"
                        },
                        {
                            "include": "#parenthesized-parameter-list"
                        },
                        {
                            "include": "#base-types"
                        },
                        {
                            "include": "#generic-constraints"
                        }
                    ]
                },
                {
                    "begin": "\\{",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.open.dm"
                        }
                    },
                    "end": "\\}",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#class-or-struct-members"
                        }
                    ]
                },
                {
                    "include": "#preprocessor"
                },
                {
                    "include": "#comment"
                }
            ]
        },
        "delegate-declaration": {
            "begin": "(?x)\n(?:\\b(delegate)\\b)\\s+\n(?<type_name>\n  (?:\n    (?:ref\\s+(?:readonly\\s+)?)?   # ref return\n    (?:\n      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name_and_type_args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s* # array suffix?\n      \\[\n        (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n      \\]\n      \\s*\n      (?:\\?)? # arrays can be nullable reference types\n      \\s*\n    )*\n  )\n)\\s+\n(\\g<identifier>)\\s*\n(<([^<>]+)>)?\\s*\n(?=\\()",
            "beginCaptures": {
                "1": {
                    "name": "storage.type.delegate.dm"
                },
                "2": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                },
                "7": {
                    "name": "entity.name.type.delegate.dm"
                },
                "8": {
                    "patterns": [
                        {
                            "include": "#type-parameter-list"
                        }
                    ]
                }
            },
            "end": "(?=;)",
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#parenthesized-parameter-list"
                },
                {
                    "include": "#generic-constraints"
                }
            ]
        },
        "enum-declaration": {
            "begin": "(?=\\benum\\b)",
            "end": "(?<=\\})",
            "patterns": [
                {
                    "begin": "(?=enum)",
                    "end": "(?=\\{)",
                    "patterns": [
                        {
                            "include": "#comment"
                        },
                        {
                            "match": "(enum)\\s+(@?[_[:alpha:]][_[:alnum:]]*)",
                            "captures": {
                                "1": {
                                    "name": "storage.type.enum.dm"
                                },
                                "2": {
                                    "name": "entity.name.type.enum.dm"
                                }
                            }
                        },
                        {
                            "begin": ":",
                            "beginCaptures": {
                                "0": {
                                    "name": "punctuation.separator.colon.dm"
                                }
                            },
                            "end": "(?=\\{)",
                            "patterns": [
                                {
                                    "include": "#type"
                                }
                            ]
                        }
                    ]
                },
                {
                    "begin": "\\{",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.open.dm"
                        }
                    },
                    "end": "\\}",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#preprocessor"
                        },
                        {
                            "include": "#comment"
                        },
                        {
                            "include": "#attribute-section"
                        },
                        {
                            "include": "#punctuation-comma"
                        },
                        {
                            "begin": "@?[_[:alpha:]][_[:alnum:]]*",
                            "beginCaptures": {
                                "0": {
                                    "name": "entity.name.variable.enum-member.dm"
                                }
                            },
                            "end": "(?=(,|\\}))",
                            "patterns": [
                                {
                                    "include": "#comment"
                                },
                                {
                                    "include": "#variable-initializer"
                                }
                            ]
                        }
                    ]
                },
                {
                    "include": "#preprocessor"
                },
                {
                    "include": "#comment"
                }
            ]
        },
        "interface-declaration": {
            "begin": "(?=\\binterface\\b)",
            "end": "(?<=\\})",
            "patterns": [
                {
                    "begin": "(?x)\n(interface)\\b\\s+\n(@?[_[:alpha:]][_[:alnum:]]*)",
                    "beginCaptures": {
                        "1": {
                            "name": "storage.type.interface.dm"
                        },
                        "2": {
                            "name": "entity.name.type.interface.dm"
                        }
                    },
                    "end": "(?=\\{)",
                    "patterns": [
                        {
                            "include": "#comment"
                        },
                        {
                            "include": "#type-parameter-list"
                        },
                        {
                            "include": "#base-types"
                        },
                        {
                            "include": "#generic-constraints"
                        }
                    ]
                },
                {
                    "begin": "\\{",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.open.dm"
                        }
                    },
                    "end": "\\}",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#interface-members"
                        }
                    ]
                },
                {
                    "include": "#preprocessor"
                },
                {
                    "include": "#comment"
                }
            ]
        },
        "record-declaration": {
            "begin": "(?=\\brecord\\b)",
            "end": "(?<=\\})|(?=;)",
            "patterns": [
                {
                    "begin": "(?x)\n(record)\\b\\s+\n(@?[_[:alpha:]][_[:alnum:]]*)",
                    "beginCaptures": {
                        "1": {
                            "name": "storage.type.record.dm"
                        },
                        "2": {
                            "name": "entity.name.type.class.dm"
                        }
                    },
                    "end": "(?=\\{)|(?=;)",
                    "patterns": [
                        {
                            "include": "#comment"
                        },
                        {
                            "include": "#type-parameter-list"
                        },
                        {
                            "include": "#parenthesized-parameter-list"
                        },
                        {
                            "include": "#base-types"
                        },
                        {
                            "include": "#generic-constraints"
                        }
                    ]
                },
                {
                    "begin": "\\{",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.open.dm"
                        }
                    },
                    "end": "\\}",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#class-or-struct-members"
                        }
                    ]
                },
                {
                    "include": "#preprocessor"
                },
                {
                    "include": "#comment"
                }
            ]
        },
        "struct-declaration": {
            "begin": "(?=(\\brecord\\b\\s+)?\\bstruct\\b)",
            "end": "(?<=\\})|(?=;)",
            "patterns": [
                {
                    "begin": "(?x)\n(\\b(record)\\b\\s+)?\n(struct)\\b\\s+\n(@?[_[:alpha:]][_[:alnum:]]*)",
                    "beginCaptures": {
                        "2": {
                            "name": "storage.type.record.dm"
                        },
                        "3": {
                            "name": "storage.type.struct.dm"
                        },
                        "4": {
                            "name": "entity.name.type.struct.dm"
                        }
                    },
                    "end": "(?=\\{)|(?=;)",
                    "patterns": [
                        {
                            "include": "#comment"
                        },
                        {
                            "include": "#type-parameter-list"
                        },
                        {
                            "include": "#parenthesized-parameter-list"
                        },
                        {
                            "include": "#base-types"
                        },
                        {
                            "include": "#generic-constraints"
                        }
                    ]
                },
                {
                    "begin": "\\{",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.open.dm"
                        }
                    },
                    "end": "\\}",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#class-or-struct-members"
                        }
                    ]
                },
                {
                    "include": "#preprocessor"
                },
                {
                    "include": "#comment"
                }
            ]
        },
        "type-parameter-list": {
            "begin": "\\<",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.definition.typeparameters.begin.dm"
                }
            },
            "end": "\\>",
            "endCaptures": {
                "0": {
                    "name": "punctuation.definition.typeparameters.end.dm"
                }
            },
            "patterns": [
                {
                    "match": "\\b(in|out)\\b",
                    "name": "storage.modifier.$1.dm"
                },
                {
                    "match": "(@?[_[:alpha:]][_[:alnum:]]*)\\b",
                    "name": "entity.name.type.type-parameter.dm"
                },
                {
                    "include": "#comment"
                },
                {
                    "include": "#punctuation-comma"
                },
                {
                    "include": "#attribute-section"
                }
            ]
        },
        "base-types": {
            "begin": ":",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.separator.colon.dm"
                }
            },
            "end": "(?=\\{|where|;)",
            "patterns": [
                {
                    "include": "#type"
                },
                {
                    "include": "#punctuation-comma"
                },
                {
                    "include": "#preprocessor"
                }
            ]
        },
        "generic-constraints": {
            "begin": "(where)\\s+(@?[_[:alpha:]][_[:alnum:]]*)\\s*(:)",
            "beginCaptures": {
                "1": {
                    "name": "storage.modifier.where.dm"
                },
                "2": {
                    "name": "entity.name.type.type-parameter.dm"
                },
                "3": {
                    "name": "punctuation.separator.colon.dm"
                }
            },
            "end": "(?=\\{|where|;|=>)",
            "patterns": [
                {
                    "name": "storage.type.class.dm",
                    "match": "\\bclass\\b"
                },
                {
                    "name": "storage.type.struct.dm",
                    "match": "\\bstruct\\b"
                },
                {
                    "match": "(new)\\s*(\\()\\s*(\\))",
                    "captures": {
                        "1": {
                            "name": "keyword.operator.expression.new.dm"
                        },
                        "2": {
                            "name": "punctuation.parenthesis.open.dm"
                        },
                        "3": {
                            "name": "punctuation.parenthesis.close.dm"
                        }
                    }
                },
                {
                    "include": "#type"
                },
                {
                    "include": "#punctuation-comma"
                },
                {
                    "include": "#generic-constraints"
                }
            ]
        },
        "field-declaration": {
            "begin": "(?x)\n(?<type_name>\n  (?:\n    (?:\n      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name_and_type_args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s* # array suffix?\n      \\[\n        (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n      \\]\n      \\s*\n      (?:\\?)? # arrays can be nullable reference types\n      \\s*\n    )*\n  )\n)\\s+\n(\\g<identifier>)\\s* # first field name\n(?!=>|==)(?=,|;|=|$)",
            "beginCaptures": {
                "1": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                },
                "6": {
                    "name": "entity.name.variable.field.dm"
                }
            },
            "end": "(?=;)",
            "patterns": [
                {
                    "name": "entity.name.variable.field.dm",
                    "match": "@?[_[:alpha:]][_[:alnum:]]*"
                },
                {
                    "include": "#punctuation-comma"
                },
                {
                    "include": "#comment"
                },
                {
                    "include": "#variable-initializer"
                },
                {
                    "include": "#class-or-struct-members"
                }
            ]
        },
        "property-declaration": {
            "begin": "(?x)\n\n# The negative lookahead below ensures that we don't match nested types\n# or other declarations as properties.\n(?![[:word:][:space:]]*\\b(?:class|interface|struct|enum|event)\\b)\n\n(?<return_type>\n  (?<type_name>\n    (?:\n      (?:ref\\s+(?:readonly\\s+)?)?   # ref return\n      (?:\n        (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n        (?<name_and_type_args> # identifier + type arguments (if any)\n          \\g<identifier>\\s*\n          (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n        )\n        (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n      )\n      (?:\\s*\\?\\s*)? # nullable suffix?\n      (?:\\s* # array suffix?\n        \\[\n          (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n        \\]\n        \\s*\n        (?:\\?)? # arrays can be nullable reference types\n        \\s*\n      )*\n    )\n  )\\s+\n)\n(?<interface_name>\\g<type_name>\\s*\\.\\s*)?\n(?<property_name>\\g<identifier>)\\s*\n(?=\\{|=>|//|/\\*|$)",
            "beginCaptures": {
                "1": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                },
                "7": {
                    "patterns": [
                        {
                            "include": "#type"
                        },
                        {
                            "include": "#punctuation-accessor"
                        }
                    ]
                },
                "8": {
                    "name": "entity.name.variable.property.dm"
                }
            },
            "end": "(?<=\\})|(?=;)",
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#property-accessors"
                },
                {
                    "include": "#accessor-getter-expression"
                },
                {
                    "include": "#variable-initializer"
                },
                {
                    "include": "#class-or-struct-members"
                }
            ]
        },
        "indexer-declaration": {
            "begin": "(?x)\n(?<return_type>\n  (?<type_name>\n    (?:\n      (?:ref\\s+(?:readonly\\s+)?)?   # ref return\n      (?:\n        (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n        (?<name_and_type_args> # identifier + type arguments (if any)\n          \\g<identifier>\\s*\n          (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n        )\n        (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n      )\n      (?:\\s*\\?\\s*)? # nullable suffix?\n      (?:\\s* # array suffix?\n        \\[\n          (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n        \\]\n        \\s*\n        (?:\\?)? # arrays can be nullable reference types\n        \\s*\n      )*\n    )\n  )\\s+\n)\n(?<interface_name>\\g<type_name>\\s*\\.\\s*)?\n(?<indexer_name>this)\\s*\n(?=\\[)",
            "beginCaptures": {
                "1": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                },
                "7": {
                    "patterns": [
                        {
                            "include": "#type"
                        },
                        {
                            "include": "#punctuation-accessor"
                        }
                    ]
                },
                "8": {
                    "name": "variable.language.this.dm"
                }
            },
            "end": "(?<=\\})|(?=;)",
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#bracketed-parameter-list"
                },
                {
                    "include": "#property-accessors"
                },
                {
                    "include": "#accessor-getter-expression"
                },
                {
                    "include": "#variable-initializer"
                }
            ]
        },
        "event-declaration": {
            "begin": "(?x)\n\\b(event)\\b\\s*\n(?<return_type>\n  (?<type_name>\n    (?:\n      (?:\n        (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n        (?<name_and_type_args> # identifier + type arguments (if any)\n          \\g<identifier>\\s*\n          (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n        )\n        (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n      )\n      (?:\\s*\\?\\s*)? # nullable suffix?\n      (?:\\s* # array suffix?\n        \\[\n          (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n        \\]\n        \\s*\n        (?:\\?)? # arrays can be nullable reference types\n        \\s*\n      )*\n    )\n  )\\s+\n)\n(?<interface_name>\\g<type_name>\\s*\\.\\s*)?\n(\\g<identifier>)\\s* # first event name\n(?=\\{|;|,|=|//|/\\*|$)",
            "beginCaptures": {
                "1": {
                    "name": "storage.type.event.dm"
                },
                "2": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                },
                "8": {
                    "patterns": [
                        {
                            "include": "#type"
                        },
                        {
                            "include": "#punctuation-accessor"
                        }
                    ]
                },
                "9": {
                    "name": "entity.name.variable.event.dm"
                }
            },
            "end": "(?<=\\})|(?=;)",
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#event-accessors"
                },
                {
                    "name": "entity.name.variable.event.dm",
                    "match": "@?[_[:alpha:]][_[:alnum:]]*"
                },
                {
                    "include": "#punctuation-comma"
                },
                {
                    "begin": "=",
                    "beginCaptures": {
                        "0": {
                            "name": "keyword.operator.assignment.dm"
                        }
                    },
                    "end": "(?<=,)|(?=;)",
                    "patterns": [
                        {
                            "include": "#expression"
                        },
                        {
                            "include": "#punctuation-comma"
                        }
                    ]
                }
            ]
        },
        "property-accessors": {
            "begin": "\\{",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.curlybrace.open.dm"
                }
            },
            "end": "\\}",
            "endCaptures": {
                "0": {
                    "name": "punctuation.curlybrace.close.dm"
                }
            },
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#attribute-section"
                },
                {
                    "name": "storage.modifier.$1.dm",
                    "match": "\\b(private|protected|internal)\\b"
                },
                {
                    "begin": "\\b(get)\\b\\s*(?=\\{|;|=>|//|/\\*|$)",
                    "beginCaptures": {
                        "1": {
                            "name": "storage.type.accessor.$1.dm"
                        }
                    },
                    "end": "(?<=\\}|;)|(?=\\})",
                    "patterns": [
                        {
                            "include": "#accessor-getter"
                        }
                    ]
                },
                {
                    "begin": "\\b(set|init)\\b\\s*(?=\\{|;|=>|//|/\\*|$)",
                    "beginCaptures": {
                        "1": {
                            "name": "storage.type.accessor.$1.dm"
                        }
                    },
                    "end": "(?<=\\}|;)|(?=\\})",
                    "patterns": [
                        {
                            "include": "#accessor-setter"
                        }
                    ]
                }
            ]
        },
        "event-accessors": {
            "begin": "\\{",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.curlybrace.open.dm"
                }
            },
            "end": "\\}",
            "endCaptures": {
                "0": {
                    "name": "punctuation.curlybrace.close.dm"
                }
            },
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#attribute-section"
                },
                {
                    "begin": "\\b(add|remove)\\b\\s*(?=\\{|;|=>|//|/\\*|$)",
                    "beginCaptures": {
                        "1": {
                            "name": "storage.type.accessor.$1.dm"
                        }
                    },
                    "end": "(?<=\\}|;)|(?=\\})",
                    "patterns": [
                        {
                            "include": "#accessor-setter"
                        }
                    ]
                }
            ]
        },
        "accessor-getter": {
            "patterns": [
                {
                    "begin": "\\{",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.open.dm"
                        }
                    },
                    "end": "\\}",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.close.dm"
                        }
                    },
                    "contentName": "meta.accessor.getter.dm",
                    "patterns": [
                        {
                            "include": "#statement"
                        }
                    ]
                },
                {
                    "include": "#accessor-getter-expression"
                },
                {
                    "include": "#punctuation-semicolon"
                }
            ]
        },
        "accessor-getter-expression": {
            "begin": "=>",
            "beginCaptures": {
                "0": {
                    "name": "keyword.operator.arrow.dm"
                }
            },
            "end": "(?=;|\\})",
            "contentName": "meta.accessor.getter.dm",
            "patterns": [
                {
                    "include": "#ref-modifier"
                },
                {
                    "include": "#expression"
                }
            ]
        },
        "accessor-setter": {
            "patterns": [
                {
                    "begin": "\\{",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.open.dm"
                        }
                    },
                    "end": "\\}",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.close.dm"
                        }
                    },
                    "contentName": "meta.accessor.setter.dm",
                    "patterns": [
                        {
                            "include": "#statement"
                        }
                    ]
                },
                {
                    "begin": "=>",
                    "beginCaptures": {
                        "0": {
                            "name": "keyword.operator.arrow.dm"
                        }
                    },
                    "end": "(?=;|\\})",
                    "contentName": "meta.accessor.setter.dm",
                    "patterns": [
                        {
                            "include": "#ref-modifier"
                        },
                        {
                            "include": "#expression"
                        }
                    ]
                },
                {
                    "include": "#punctuation-semicolon"
                }
            ]
        },
        "method-declaration": {
            "begin": "(?x)\n(?<return_type>\n  (?<type_name>\n    (?:\n      (?:ref\\s+(?:readonly\\s+)?)?   # ref return\n      (?:\n        (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n        (?<name_and_type_args> # identifier + type arguments (if any)\n          \\g<identifier>\\s*\n          (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n        )\n        (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n      )\n      (?:\\s*\\?\\s*)? # nullable suffix?\n      (?:\\s* # array suffix?\n        \\[\n          (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n        \\]\n        \\s*\n        (?:\\?)? # arrays can be nullable reference types\n        \\s*\n      )*\n    )\n  )\\s+\n)\n(?<interface_name>\\g<type_name>\\s*\\.\\s*)?\n(\\g<identifier>)\\s*\n(<([^<>]+)>)?\\s*\n(?=\\()",
            "beginCaptures": {
                "1": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                },
                "7": {
                    "patterns": [
                        {
                            "include": "#type"
                        },
                        {
                            "include": "#punctuation-accessor"
                        }
                    ]
                },
                "8": {
                    "name": "entity.name.function.dm"
                },
                "9": {
                    "patterns": [
                        {
                            "include": "#type-parameter-list"
                        }
                    ]
                }
            },
            "end": "(?<=\\})|(?=;)",
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#parenthesized-parameter-list"
                },
                {
                    "include": "#generic-constraints"
                },
                {
                    "include": "#expression-body"
                },
                {
                    "include": "#block"
                }
            ]
        },
        "constructor-declaration": {
            "begin": "(?=@?[_[:alpha:]][_[:alnum:]]*\\s*\\()",
            "end": "(?<=\\})|(?=;)",
            "patterns": [
                {
                    "match": "(@?[_[:alpha:]][_[:alnum:]]*)\\b",
                    "captures": {
                        "1": {
                            "name": "entity.name.function.dm"
                        }
                    }
                },
                {
                    "begin": "(:)",
                    "beginCaptures": {
                        "1": {
                            "name": "punctuation.separator.colon.dm"
                        }
                    },
                    "end": "(?=\\{|=>)",
                    "patterns": [
                        {
                            "include": "#constructor-initializer"
                        }
                    ]
                },
                {
                    "include": "#parenthesized-parameter-list"
                },
                {
                    "include": "#preprocessor"
                },
                {
                    "include": "#comment"
                },
                {
                    "include": "#expression-body"
                },
                {
                    "include": "#block"
                }
            ]
        },
        "constructor-initializer": {
            "begin": "\\b(base|this)\\b\\s*(?=\\()",
            "beginCaptures": {
                "1": {
                    "name": "variable.language.$1.dm"
                }
            },
            "end": "(?<=\\))",
            "patterns": [
                {
                    "include": "#argument-list"
                }
            ]
        },
        "destructor-declaration": {
            "begin": "(~)(@?[_[:alpha:]][_[:alnum:]]*)\\s*(?=\\()",
            "beginCaptures": {
                "1": {
                    "name": "punctuation.tilde.dm"
                },
                "2": {
                    "name": "entity.name.function.dm"
                }
            },
            "end": "(?<=\\})|(?=;)",
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#parenthesized-parameter-list"
                },
                {
                    "include": "#expression-body"
                },
                {
                    "include": "#block"
                }
            ]
        },
        "operator-declaration": {
            "begin": "(?x)\n(?<type_name>\n  (?:\n    (?:ref\\s+(?:readonly\\s+)?)?   # ref return\n    (?:\n      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name_and_type_args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s* # array suffix?\n      \\[\n        (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n      \\]\n      \\s*\n      (?:\\?)? # arrays can be nullable reference types\n      \\s*\n    )*\n  )\n)\\s*\n\\b(?<operator_keyword>operator)\\b\\s*\n(?<operator>[+\\-*/%&|\\^!=~<>]+|true|false)\\s*\n(?=\\()",
            "beginCaptures": {
                "1": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                },
                "6": {
                    "name": "storage.type.operator.dm"
                },
                "7": {
                    "name": "entity.name.function.dm"
                }
            },
            "end": "(?<=\\})|(?=;)",
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#parenthesized-parameter-list"
                },
                {
                    "include": "#expression-body"
                },
                {
                    "include": "#block"
                }
            ]
        },
        "conversion-operator-declaration": {
            "begin": "(?x)\n(?<explicit_or_implicit_keyword>(?:\\b(?:explicit|implicit)))\\s*\n(?<operator_keyword>(?:\\b(?:operator)))\\s*\n(?<type_name>\n  (?:\n    (?:ref\\s+(?:readonly\\s+)?)?   # ref return\n    (?:\n      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name_and_type_args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s* # array suffix?\n      \\[\n        (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n      \\]\n      \\s*\n      (?:\\?)? # arrays can be nullable reference types\n      \\s*\n    )*\n  )\n)\\s*\n(?=\\()",
            "beginCaptures": {
                "1": {
                    "patterns": [
                        {
                            "match": "\\b(explicit)\\b",
                            "captures": {
                                "1": {
                                    "name": "storage.modifier.explicit.dm"
                                }
                            }
                        },
                        {
                            "match": "\\b(implicit)\\b",
                            "captures": {
                                "1": {
                                    "name": "storage.modifier.implicit.dm"
                                }
                            }
                        }
                    ]
                },
                "2": {
                    "name": "storage.type.operator.dm"
                },
                "3": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                }
            },
            "end": "(?<=\\})|(?=;)",
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#parenthesized-parameter-list"
                },
                {
                    "include": "#expression-body"
                },
                {
                    "include": "#block"
                }
            ]
        },
        "block": {
            "begin": "\\{",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.curlybrace.open.dm"
                }
            },
            "end": "\\}",
            "endCaptures": {
                "0": {
                    "name": "punctuation.curlybrace.close.dm"
                }
            },
            "patterns": [
                {
                    "include": "#statement"
                }
            ]
        },
        "variable-initializer": {
            "begin": "(?<!=|!)(=)(?!=|>)",
            "beginCaptures": {
                "1": {
                    "name": "keyword.operator.assignment.dm"
                }
            },
            "end": "(?=[,\\)\\];}])",
            "patterns": [
                {
                    "include": "#ref-modifier"
                },
                {
                    "include": "#expression"
                }
            ]
        },
        "expression-body": {
            "begin": "=>",
            "beginCaptures": {
                "0": {
                    "name": "keyword.operator.arrow.dm"
                }
            },
            "end": "(?=[,\\);}])",
            "patterns": [
                {
                    "include": "#ref-modifier"
                },
                {
                    "include": "#expression"
                }
            ]
        },
        "goto-statement": {
            "begin": "(?<!\\.)\\b(goto)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.flow.goto.dm"
                }
            },
            "end": "(?=[;}])",
            "patterns": [
                {
                    "begin": "\\b(case)\\b",
                    "beginCaptures": {
                        "1": {
                            "name": "keyword.control.conditional.case.dm"
                        }
                    },
                    "end": "(?=[;}])",
                    "patterns": [
                        {
                            "include": "#expression"
                        }
                    ]
                },
                {
                    "match": "\\b(default)\\b",
                    "captures": {
                        "1": {
                            "name": "keyword.control.conditional.default.dm"
                        }
                    }
                },
                {
                    "name": "entity.name.label.dm",
                    "match": "@?[_[:alpha:]][_[:alnum:]]*"
                }
            ]
        },
        "return-statement": {
            "begin": "(?<!\\.)\\b(return)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.flow.return.dm"
                }
            },
            "end": "(?=[;}])",
            "patterns": [
                {
                    "include": "#ref-modifier"
                },
                {
                    "include": "#expression"
                }
            ]
        },
        "break-or-continue-statement": {
            "match": "(?<!\\.)\\b(break|continue)\\b",
            "name": "keyword.control.flow.$1.dm"
        },
        "throw-statement": {
            "begin": "(?<!\\.)\\b(throw)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.flow.throw.dm"
                }
            },
            "end": "(?=[;}])",
            "patterns": [
                {
                    "include": "#expression"
                }
            ]
        },
        "yield-statement": {
            "patterns": [
                {
                    "include": "#yield-return-statement"
                },
                {
                    "include": "#yield-break-statement"
                }
            ]
        },
        "yield-return-statement": {
            "begin": "(?<!\\.)\\b(yield)\\b\\s*\\b(return)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.flow.yield.dm"
                },
                "2": {
                    "name": "keyword.control.flow.return.dm"
                }
            },
            "end": "(?=[;}])",
            "patterns": [
                {
                    "include": "#expression"
                }
            ]
        },
        "yield-break-statement": {
            "match": "(?<!\\.)\\b(yield)\\b\\s*\\b(break)\\b",
            "captures": {
                "1": {
                    "name": "keyword.control.flow.yield.dm"
                },
                "2": {
                    "name": "keyword.control.flow.break.dm"
                }
            }
        },
        "await-statement": {
            "begin": "(?<!\\.\\s*)\\b(await)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.operator.expression.await.dm"
                }
            },
            "end": "(?<=})|(?=;|})",
            "patterns": [
                {
                    "include": "#foreach-statement"
                },
                {
                    "include": "#using-statement"
                },
                {
                    "include": "#expression"
                }
            ]
        },
        "if-statement": {
            "begin": "(?<!\\.)\\b(if)\\b\\s*(?=\\()",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.conditional.if.dm"
                }
            },
            "end": "(?<=})|(?=;)",
            "patterns": [
                {
                    "begin": "\\(",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.open.dm"
                        }
                    },
                    "end": "\\)",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#expression"
                        }
                    ]
                },
                {
                    "include": "#statement"
                }
            ]
        },
        "else-part": {
            "begin": "(?<!\\.)\\b(else)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.conditional.else.dm"
                }
            },
            "end": "(?<=})|(?=;)",
            "patterns": [
                {
                    "include": "#statement"
                }
            ]
        },
        "switch-statement-or-expression": {
            "begin": "(?<!\\.)\\b(switch)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.conditional.switch.dm"
                }
            },
            "end": "(?<=})|(?=})",
            "patterns": [
                {
                    "include": "#intrusive"
                },
                {
                    "begin": "(?=\\()",
                    "end": "(?<=\\})|(?=\\})",
                    "patterns": [
                        {
                            "include": "#switch-statement"
                        }
                    ]
                },
                {
                    "begin": "(?=\\{)",
                    "end": "(?<=\\})|(?=\\})",
                    "patterns": [
                        {
                            "include": "#switch-expression"
                        }
                    ]
                }
            ]
        },
        "switch-statement": {
            "patterns": [
                {
                    "include": "#intrusive"
                },
                {
                    "begin": "\\(",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.open.dm"
                        }
                    },
                    "end": "\\)",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#expression"
                        }
                    ]
                },
                {
                    "begin": "\\{",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.open.dm"
                        }
                    },
                    "end": "\\}",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#switch-label"
                        },
                        {
                            "include": "#statement"
                        }
                    ]
                }
            ]
        },
        "switch-label": {
            "begin": "\\b(case|default)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.conditional.$1.dm"
                }
            },
            "end": "(:)|(?=})",
            "endCaptures": {
                "1": {
                    "name": "punctuation.separator.colon.dm"
                }
            },
            "patterns": [
                {
                    "begin": "\\b(when)\\b",
                    "beginCaptures": {
                        "1": {
                            "name": "keyword.control.conditional.when.dm"
                        }
                    },
                    "end": "(?=:|})",
                    "patterns": [
                        {
                            "include": "#case-guard"
                        }
                    ]
                },
                {
                    "begin": "(?!\\s)",
                    "end": "(?=\\bwhen\\b|:|})",
                    "patterns": [
                        {
                            "include": "#pattern"
                        }
                    ]
                }
            ]
        },
        "switch-expression": {
            "begin": "\\{",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.curlybrace.open.dm"
                }
            },
            "end": "\\}",
            "endCaptures": {
                "0": {
                    "name": "punctuation.curlybrace.close.dm"
                }
            },
            "patterns": [
                {
                    "include": "#punctuation-comma"
                },
                {
                    "begin": "=>",
                    "beginCaptures": {
                        "0": {
                            "name": "keyword.operator.arrow.dm"
                        }
                    },
                    "end": "(?=,|})",
                    "patterns": [
                        {
                            "include": "#expression"
                        }
                    ]
                },
                {
                    "begin": "\\b(when)\\b",
                    "beginCaptures": {
                        "1": {
                            "name": "keyword.control.conditional.when.dm"
                        }
                    },
                    "end": "(?==>|,|})",
                    "patterns": [
                        {
                            "include": "#case-guard"
                        }
                    ]
                },
                {
                    "begin": "(?!\\s)",
                    "end": "(?=\\bwhen\\b|=>|,|})",
                    "patterns": [
                        {
                            "include": "#pattern"
                        }
                    ]
                }
            ]
        },
        "case-guard": {
            "patterns": [
                {
                    "include": "#parenthesized-expression"
                },
                {
                    "include": "#expression"
                }
            ]
        },
        "is-expression": {
            "begin": "(?<!\\.)\\b(is)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.operator.expression.pattern.is.dm"
                }
            },
            "end": "(?=[)}\\],;:?=&|^]|!=)",
            "patterns": [
                {
                    "include": "#pattern"
                }
            ]
        },
        "pattern": {
            "patterns": [
                {
                    "include": "#intrusive"
                },
                {
                    "include": "#combinator-pattern"
                },
                {
                    "include": "#discard-pattern"
                },
                {
                    "include": "#constant-pattern"
                },
                {
                    "include": "#relational-pattern"
                },
                {
                    "include": "#var-pattern"
                },
                {
                    "include": "#type-pattern"
                },
                {
                    "include": "#positional-pattern"
                },
                {
                    "include": "#property-pattern"
                },
                {
                    "include": "#list-pattern"
                },
                {
                    "include": "#slice-pattern"
                }
            ]
        },
        "combinator-pattern": {
            "match": "\\b(and|or|not)\\b",
            "name": "keyword.operator.expression.pattern.combinator.$1.dm"
        },
        "discard-pattern": {
            "match": "_(?![_[:alnum:]])",
            "name": "variable.language.discard.dm"
        },
        "constant-pattern": {
            "patterns": [
                {
                    "include": "#boolean-literal"
                },
                {
                    "include": "#null-literal"
                },
                {
                    "include": "#numeric-literal"
                },
                {
                    "include": "#char-literal"
                },
                {
                    "include": "#string-literal"
                },
                {
                    "include": "#raw-string-literal"
                },
                {
                    "include": "#verbatim-string-literal"
                },
                {
                    "include": "#type-operator-expression"
                },
                {
                    "include": "#expression-operator-expression"
                },
                {
                    "include": "#expression-operators"
                },
                {
                    "include": "#casted-constant-pattern"
                }
            ]
        },
        "casted-constant-pattern": {
            "begin": "(?x)\n(\\()\n  ([\\s.:@_[:alnum:]]+)\n(\\))\n(?=[\\s+\\-!~]*@?[_[:alnum:]('\"]+)",
            "beginCaptures": {
                "1": {
                    "name": "punctuation.parenthesis.open.dm"
                },
                "2": {
                    "patterns": [
                        {
                            "include": "#type-builtin"
                        },
                        {
                            "include": "#type-name"
                        }
                    ]
                },
                "3": {
                    "name": "punctuation.parenthesis.close.dm"
                }
            },
            "end": "(?=[)}\\],;:?=&|^]|!=|\\b(and|or|when)\\b)",
            "patterns": [
                {
                    "include": "#casted-constant-pattern"
                },
                {
                    "begin": "\\(",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.open.dm"
                        }
                    },
                    "end": "\\)",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#constant-pattern"
                        }
                    ]
                },
                {
                    "include": "#constant-pattern"
                },
                {
                    "match": "(@?[_[:alpha:]][_[:alnum:]]*)\\s*(\\:\\:)",
                    "captures": {
                        "1": {
                            "name": "entity.name.type.alias.dm"
                        },
                        "2": {
                            "name": "punctuation.separator.coloncolon.dm"
                        }
                    }
                },
                {
                    "match": "(@?[_[:alpha:]][_[:alnum:]]*)\\s*(\\.)",
                    "captures": {
                        "1": {
                            "name": "entity.name.type.dm"
                        },
                        "2": {
                            "name": "punctuation.accessor.dm"
                        }
                    }
                },
                {
                    "match": "\\@?[_[:alpha:]][_[:alnum:]]*",
                    "name": "variable.other.constant.dm"
                }
            ]
        },
        "relational-pattern": {
            "begin": "<=?|>=?",
            "beginCaptures": {
                "0": {
                    "name": "keyword.operator.relational.dm"
                }
            },
            "end": "(?=[)}\\],;:?=&|^]|!=|\\b(and|or|when)\\b)",
            "patterns": [
                {
                    "include": "#expression"
                }
            ]
        },
        "var-pattern": {
            "begin": "\\b(var)\\b",
            "beginCaptures": {
                "1": {
                    "name": "storage.type.var.dm"
                }
            },
            "end": "(?=[)}\\],;:?=&|^]|!=|\\b(and|or|when)\\b)",
            "patterns": [
                {
                    "include": "#designation-pattern"
                }
            ]
        },
        "designation-pattern": {
            "patterns": [
                {
                    "include": "#intrusive"
                },
                {
                    "begin": "\\(",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.open.dm"
                        }
                    },
                    "end": "\\)",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#punctuation-comma"
                        },
                        {
                            "include": "#designation-pattern"
                        }
                    ]
                },
                {
                    "include": "#simple-designation-pattern"
                }
            ]
        },
        "simple-designation-pattern": {
            "patterns": [
                {
                    "include": "#discard-pattern"
                },
                {
                    "match": "@?[_[:alpha:]][_[:alnum:]]*",
                    "name": "entity.name.variable.local.dm"
                }
            ]
        },
        "type-pattern": {
            "begin": "(?=@?[_[:alpha:]][_[:alnum:]]*)",
            "end": "(?=[)}\\],;:?=&|^]|!=|\\b(and|or|when)\\b)",
            "patterns": [
                {
                    "begin": "\\G",
                    "end": "(?!\\G[@_[:alpha:]])(?=[\\({@_[:alpha:])}\\],;:=&|^]|(?:\\s|^)\\?|!=|\\b(and|or|when)\\b)",
                    "patterns": [
                        {
                            "include": "#intrusive"
                        },
                        {
                            "include": "#type-subpattern"
                        }
                    ]
                },
                {
                    "begin": "(?=[\\({@_[:alpha:]])",
                    "end": "(?=[)}\\],;:?=&|^]|!=|\\b(and|or|when)\\b)",
                    "patterns": [
                        {
                            "include": "#intrusive"
                        },
                        {
                            "include": "#positional-pattern"
                        },
                        {
                            "include": "#property-pattern"
                        },
                        {
                            "include": "#simple-designation-pattern"
                        }
                    ]
                }
            ]
        },
        "type-subpattern": {
            "patterns": [
                {
                    "include": "#type-builtin"
                },
                {
                    "begin": "(@?[_[:alpha:]][_[:alnum:]]*)\\s*(::)",
                    "beginCaptures": {
                        "1": {
                            "name": "entity.name.type.alias.dm"
                        },
                        "2": {
                            "name": "punctuation.separator.coloncolon.dm"
                        }
                    },
                    "end": "(?<=[_[:alnum:]])|(?=[.<\\[\\({)}\\],;:?=&|^]|!=|\\b(and|or|when)\\b)",
                    "patterns": [
                        {
                            "include": "#intrusive"
                        },
                        {
                            "match": "\\@?[_[:alpha:]][_[:alnum:]]*",
                            "name": "entity.name.type.dm"
                        }
                    ]
                },
                {
                    "match": "\\@?[_[:alpha:]][_[:alnum:]]*",
                    "name": "entity.name.type.dm"
                },
                {
                    "begin": "\\.",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.accessor.dm"
                        }
                    },
                    "end": "(?<=[_[:alnum:]])|(?=[<\\[\\({)}\\],;:?=&|^]|!=|\\b(and|or|when)\\b)",
                    "patterns": [
                        {
                            "include": "#intrusive"
                        },
                        {
                            "match": "\\@?[_[:alpha:]][_[:alnum:]]*",
                            "name": "entity.name.type.dm"
                        }
                    ]
                },
                {
                    "include": "#type-arguments"
                },
                {
                    "include": "#type-array-suffix"
                },
                {
                    "match": "(?<!\\s)\\?",
                    "name": "punctuation.separator.question-mark.dm"
                }
            ]
        },
        "positional-pattern": {
            "begin": "(?=\\()",
            "end": "(?=[)}\\],;:?=&|^]|!=|\\b(and|or|when)\\b)",
            "patterns": [
                {
                    "begin": "\\(",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.open.dm"
                        }
                    },
                    "end": "\\)",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#subpattern"
                        },
                        {
                            "include": "#punctuation-comma"
                        }
                    ]
                },
                {
                    "begin": "(?<=\\))",
                    "end": "(?=[)}\\],;:?=&|^]|!=|\\b(and|or|when)\\b)",
                    "patterns": [
                        {
                            "include": "#intrusive"
                        },
                        {
                            "include": "#property-pattern"
                        },
                        {
                            "include": "#simple-designation-pattern"
                        }
                    ]
                }
            ]
        },
        "property-pattern": {
            "begin": "(?={)",
            "end": "(?=[)}\\],;:?=&|^]|!=|\\b(and|or|when)\\b)",
            "patterns": [
                {
                    "begin": "\\{",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.open.dm"
                        }
                    },
                    "end": "\\}",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.curlybrace.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#subpattern"
                        },
                        {
                            "include": "#punctuation-comma"
                        }
                    ]
                },
                {
                    "begin": "(?<=\\})",
                    "end": "(?=[)}\\],;:?=&|^]|!=|\\b(and|or|when)\\b)",
                    "patterns": [
                        {
                            "include": "#intrusive"
                        },
                        {
                            "include": "#simple-designation-pattern"
                        }
                    ]
                }
            ]
        },
        "subpattern": {
            "patterns": [
                {
                    "match": "(@?[_[:alpha:]][_[:alnum:]]*(?:\\s*\\.\\s*@?[_[:alpha:]][_[:alnum:]]*)*)\\s*(:)",
                    "captures": {
                        "1": {
                            "patterns": [
                                {
                                    "match": "\\@?[_[:alpha:]][_[:alnum:]]*",
                                    "name": "variable.other.object.property.dm"
                                },
                                {
                                    "include": "#punctuation-accessor"
                                }
                            ]
                        },
                        "2": {
                            "name": "punctuation.separator.colon.dm"
                        }
                    }
                },
                {
                    "include": "#pattern"
                }
            ]
        },
        "list-pattern": {
            "begin": "(?=\\[)",
            "end": "(?=[)}\\],;:?=&|^]|!=|\\b(and|or|when)\\b)",
            "patterns": [
                {
                    "begin": "\\[",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.squarebracket.open.dm"
                        }
                    },
                    "end": "\\]",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.squarebracket.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#pattern"
                        },
                        {
                            "include": "#punctuation-comma"
                        }
                    ]
                },
                {
                    "begin": "(?<=\\])",
                    "end": "(?=[)}\\],;:?=&|^]|!=|\\b(and|or|when)\\b)",
                    "patterns": [
                        {
                            "include": "#intrusive"
                        },
                        {
                            "include": "#simple-designation-pattern"
                        }
                    ]
                }
            ]
        },
        "slice-pattern": {
            "match": "\\.\\.",
            "name": "keyword.operator.range.dm"
        },
        "do-statement": {
            "begin": "(?<!\\.)\\b(do)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.loop.do.dm"
                }
            },
            "end": "(?=;|})",
            "patterns": [
                {
                    "include": "#statement"
                }
            ]
        },
        "while-statement": {
            "begin": "(?<!\\.)\\b(while)\\b\\s*(?=\\()",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.loop.while.dm"
                }
            },
            "end": "(?<=\\})|(?=;)",
            "patterns": [
                {
                    "begin": "\\(",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.open.dm"
                        }
                    },
                    "end": "\\)",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#expression"
                        }
                    ]
                },
                {
                    "include": "#statement"
                }
            ]
        },
        "for-statement": {
            "begin": "\\b(for)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.loop.for.dm"
                }
            },
            "end": "(?<=\\))|(?=;|})",
            "patterns": [
                {
                    "begin": "\\(",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.open.dm"
                        }
                    },
                    "end": "\\)",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "begin": "\\G",
                            "end": "(?=;|\\))",
                            "patterns": [
                                {
                                    "include": "#intrusive"
                                },
                                {
                                    "include": "#local-variable-declaration"
                                }
                            ]
                        },
                        {
                            "begin": "(?=;)",
                            "end": "(?=\\))",
                            "patterns": [
                                {
                                    "include": "#intrusive"
                                },
                                {
                                    "include": "#expression"
                                },
                                {
                                    "include": "#punctuation-comma"
                                },
                                {
                                    "include": "#punctuation-semicolon"
                                }
                            ]
                        }
                    ]
                }
            ]
        },
        "foreach-statement": {
            "begin": "\\b(foreach)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.loop.foreach.dm"
                }
            },
            "end": "(?<=\\))|(?=;|})",
            "patterns": [
                {
                    "include": "#intrusive"
                },
                {
                    "begin": "\\(",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.open.dm"
                        }
                    },
                    "end": "\\)",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#intrusive"
                        },
                        {
                            "match": "(?x)\n(?:\n  (\\bvar\\b)|\n  (?<type_name>\n    (?:\n      (?:\n        (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n        (?<name_and_type_args> # identifier + type arguments (if any)\n          \\g<identifier>\\s*\n          (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n        )\n        (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n      )\n      (?:\\s*\\?\\s*)? # nullable suffix?\n      (?:\\s* # array suffix?\n        \\[\n          (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n        \\]\n        \\s*\n        (?:\\?)? # arrays can be nullable reference types\n        \\s*\n      )*\n    )\n  )\n)\\s+\n(\\g<identifier>)\\s+\n\\b(in)\\b",
                            "captures": {
                                "1": {
                                    "name": "storage.type.var.dm"
                                },
                                "2": {
                                    "patterns": [
                                        {
                                            "include": "#type"
                                        }
                                    ]
                                },
                                "7": {
                                    "name": "entity.name.variable.local.dm"
                                },
                                "8": {
                                    "name": "keyword.control.loop.in.dm"
                                }
                            }
                        },
                        {
                            "match": "(?x) # match foreach (var (x, y) in ...)\n(?:\\b(var)\\b\\s*)?\n(?<tuple>\\((?:[^\\(\\)]|\\g<tuple>)+\\))\\s+\n\\b(in)\\b",
                            "captures": {
                                "1": {
                                    "name": "storage.type.var.dm"
                                },
                                "2": {
                                    "patterns": [
                                        {
                                            "include": "#tuple-declaration-deconstruction-element-list"
                                        }
                                    ]
                                },
                                "3": {
                                    "name": "keyword.control.loop.in.dm"
                                }
                            }
                        },
                        {
                            "include": "#expression"
                        }
                    ]
                }
            ]
        },
        "try-statement": {
            "patterns": [
                {
                    "include": "#try-block"
                },
                {
                    "include": "#catch-clause"
                },
                {
                    "include": "#finally-clause"
                }
            ]
        },
        "try-block": {
            "begin": "(?<!\\.)\\b(try)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.exception.try.dm"
                }
            },
            "end": "(?<=\\})",
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#block"
                }
            ]
        },
        "finally-clause": {
            "begin": "(?<!\\.)\\b(finally)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.exception.finally.dm"
                }
            },
            "end": "(?<=\\})",
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#block"
                }
            ]
        },
        "catch-clause": {
            "begin": "(?<!\\.)\\b(catch)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.exception.catch.dm"
                }
            },
            "end": "(?<=\\})",
            "patterns": [
                {
                    "begin": "\\(",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.open.dm"
                        }
                    },
                    "end": "\\)",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "match": "(?x)\n(?<type_name>\n  (?:\n    (?:\n      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name_and_type_args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s* # array suffix?\n      \\[\n        (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n      \\]\n      \\s*\n      (?:\\?)? # arrays can be nullable reference types\n      \\s*\n    )*\n  )\n)\\s*\n(?:(\\g<identifier>)\\b)?",
                            "captures": {
                                "1": {
                                    "patterns": [
                                        {
                                            "include": "#type"
                                        }
                                    ]
                                },
                                "6": {
                                    "name": "entity.name.variable.local.dm"
                                }
                            }
                        }
                    ]
                },
                {
                    "include": "#when-clause"
                },
                {
                    "include": "#comment"
                },
                {
                    "include": "#block"
                }
            ]
        },
        "when-clause": {
            "begin": "(?<!\\.)\\b(when)\\b\\s*(\\()",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.exception.when.dm"
                },
                "2": {
                    "name": "punctuation.parenthesis.open.dm"
                }
            },
            "end": "\\)",
            "endCaptures": {
                "0": {
                    "name": "punctuation.parenthesis.close.dm"
                }
            },
            "patterns": [
                {
                    "include": "#expression"
                },
                {
                    "include": "#comment"
                }
            ]
        },
        "context-control-statement": {
            "match": "\\b(checked|unchecked|unsafe)\\b(?!\\s*[@_[:alpha:](])",
            "name": "keyword.control.context.$1.dm"
        },
        "context-control-paren-statement": {
            "patterns": [
                {
                    "include": "#fixed-statement"
                },
                {
                    "include": "#lock-statement"
                },
                {
                    "include": "#using-statement"
                }
            ]
        },
        "fixed-statement": {
            "begin": "\\b(fixed)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.context.fixed.dm"
                }
            },
            "end": "(?<=\\))|(?=;|})",
            "patterns": [
                {
                    "include": "#intrusive"
                },
                {
                    "begin": "\\(",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.open.dm"
                        }
                    },
                    "end": "\\)",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#intrusive"
                        },
                        {
                            "include": "#local-variable-declaration"
                        }
                    ]
                }
            ]
        },
        "lock-statement": {
            "begin": "\\b(lock)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.context.lock.dm"
                }
            },
            "end": "(?<=\\))|(?=;|})",
            "patterns": [
                {
                    "include": "#intrusive"
                },
                {
                    "begin": "\\(",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.open.dm"
                        }
                    },
                    "end": "\\)",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#intrusive"
                        },
                        {
                            "include": "#expression"
                        }
                    ]
                }
            ]
        },
        "using-statement": {
            "begin": "\\b(using)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.control.context.using.dm"
                }
            },
            "end": "(?<=\\))|(?=;|})",
            "patterns": [
                {
                    "include": "#intrusive"
                },
                {
                    "begin": "\\(",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.open.dm"
                        }
                    },
                    "end": "\\)",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#intrusive"
                        },
                        {
                            "include": "#await-expression"
                        },
                        {
                            "include": "#local-variable-declaration"
                        },
                        {
                            "include": "#expression"
                        }
                    ]
                },
                {
                    "include": "#local-variable-declaration"
                }
            ]
        },
        "labeled-statement": {
            "match": "(@?[_[:alpha:]][_[:alnum:]]*)\\s*(:)",
            "captures": {
                "1": {
                    "name": "entity.name.label.dm"
                },
                "2": {
                    "name": "punctuation.separator.colon.dm"
                }
            }
        },
        "local-declaration": {
            "patterns": [
                {
                    "include": "#local-constant-declaration"
                },
                {
                    "include": "#local-variable-declaration"
                },
                {
                    "include": "#local-function-declaration"
                },
                {
                    "include": "#local-tuple-var-deconstruction"
                }
            ]
        },
        "local-variable-declaration": {
            "begin": "(?x)\n(?:\n  (?:(\\bref)\\s+(?:(\\breadonly)\\s+)?)?(\\bvar\\b)| # ref local\n  (?<type_name>\n    (?:\n      (?:ref\\s+(?:readonly\\s+)?)?   # ref local\n      (?:\n        (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n        (?<name_and_type_args> # identifier + type arguments (if any)\n          \\g<identifier>\\s*\n          (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n        )\n        (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n      )\n      (?:\\s*[?*]\\s*)? # nullable or pointer suffix?\n      (?:\\s* # array suffix?\n        \\[\n          (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n        \\]\n        \\s*\n        (?:\\?)? # arrays can be nullable reference types\n        \\s*\n      )*\n    )\n  )\n)\\s+\n(\\g<identifier>)\\s*\n(?!=>)\n(?=,|;|=|\\))",
            "beginCaptures": {
                "1": {
                    "name": "storage.modifier.ref.dm"
                },
                "2": {
                    "name": "storage.modifier.readonly.dm"
                },
                "3": {
                    "name": "storage.type.var.dm"
                },
                "4": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                },
                "9": {
                    "name": "entity.name.variable.local.dm"
                }
            },
            "end": "(?=[;)}])",
            "patterns": [
                {
                    "name": "entity.name.variable.local.dm",
                    "match": "@?[_[:alpha:]][_[:alnum:]]*"
                },
                {
                    "include": "#punctuation-comma"
                },
                {
                    "include": "#comment"
                },
                {
                    "include": "#variable-initializer"
                }
            ]
        },
        "local-constant-declaration": {
            "begin": "(?x)\n(?<const_keyword>\\b(?:const)\\b)\\s*\n(?<type_name>\n  (?:\n    (?:\n      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name_and_type_args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s* # array suffix?\n      \\[\n        (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n      \\]\n      \\s*\n      (?:\\?)? # arrays can be nullable reference types\n      \\s*\n    )*\n  )\n)\\s+\n(\\g<identifier>)\\s*\n(?=,|;|=)",
            "beginCaptures": {
                "1": {
                    "name": "storage.modifier.const.dm"
                },
                "2": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                },
                "7": {
                    "name": "entity.name.variable.local.dm"
                }
            },
            "end": "(?=;)",
            "patterns": [
                {
                    "name": "entity.name.variable.local.dm",
                    "match": "@?[_[:alpha:]][_[:alnum:]]*"
                },
                {
                    "include": "#punctuation-comma"
                },
                {
                    "include": "#comment"
                },
                {
                    "include": "#variable-initializer"
                }
            ]
        },
        "local-function-declaration": {
            "begin": "(?x)\n\\b((?:(?:async|unsafe|static|extern)\\s+)*)\n(?<type_name>\n  (?:ref\\s+(?:readonly\\s+)?)?   # ref return\n  (?:\n    (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n    (?<name_and_type_args> # identifier + type arguments (if any)\n      \\g<identifier>\\s*\n      (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n    )\n    (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n    (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n  )\n  (?:\\s*\\?)? # nullable suffix?\n  (?:\\s* # array suffix?\n    \\[\n      \\s*(?:,\\s*)* # commata for multi-dimensional arrays\n    \\]\n    (?:\\s*\\?)? # arrays can be nullable reference types\n  )*\n)\\s+\n(\\g<identifier>)\\s*\n(<[^<>]+>)?\\s*\n(?=\\()",
            "beginCaptures": {
                "1": {
                    "patterns": [
                        {
                            "include": "#storage-modifier"
                        }
                    ]
                },
                "2": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                },
                "7": {
                    "name": "entity.name.function.dm"
                },
                "8": {
                    "patterns": [
                        {
                            "include": "#type-parameter-list"
                        }
                    ]
                }
            },
            "end": "(?<=\\})|(?=;)",
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#parenthesized-parameter-list"
                },
                {
                    "include": "#generic-constraints"
                },
                {
                    "include": "#expression-body"
                },
                {
                    "include": "#block"
                }
            ]
        },
        "local-tuple-var-deconstruction": {
            "begin": "(?x) # e.g. var (x, y) = GetPoint();\n(?:\\b(var)\\b\\s*)\n(?<tuple>\\((?:[^\\(\\)]|\\g<tuple>)+\\))\\s*\n(?=;|=|\\))",
            "beginCaptures": {
                "1": {
                    "name": "storage.type.var.dm"
                },
                "2": {
                    "patterns": [
                        {
                            "include": "#tuple-declaration-deconstruction-element-list"
                        }
                    ]
                }
            },
            "end": "(?=;|\\))",
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#variable-initializer"
                }
            ]
        },
        "tuple-deconstruction-assignment": {
            "match": "(?x)\n(?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\\s*\n(?!=>|==)(?==)",
            "captures": {
                "1": {
                    "patterns": [
                        {
                            "include": "#tuple-deconstruction-element-list"
                        }
                    ]
                }
            }
        },
        "tuple-declaration-deconstruction-element-list": {
            "begin": "\\(",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.parenthesis.open.dm"
                }
            },
            "end": "\\)",
            "endCaptures": {
                "0": {
                    "name": "punctuation.parenthesis.close.dm"
                }
            },
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#tuple-declaration-deconstruction-element-list"
                },
                {
                    "include": "#declaration-expression-tuple"
                },
                {
                    "include": "#punctuation-comma"
                },
                {
                    "match": "(?x) # e.g. x\n(@?[_[:alpha:]][_[:alnum:]]*)\\b\\s*\n(?=[,)])",
                    "captures": {
                        "1": {
                            "name": "entity.name.variable.tuple-element.dm"
                        }
                    }
                }
            ]
        },
        "tuple-deconstruction-element-list": {
            "begin": "\\(",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.parenthesis.open.dm"
                }
            },
            "end": "\\)",
            "endCaptures": {
                "0": {
                    "name": "punctuation.parenthesis.close.dm"
                }
            },
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#tuple-deconstruction-element-list"
                },
                {
                    "include": "#declaration-expression-tuple"
                },
                {
                    "include": "#punctuation-comma"
                },
                {
                    "match": "(?x) # e.g. x\n(@?[_[:alpha:]][_[:alnum:]]*)\\b\\s*\n(?=[,)])",
                    "captures": {
                        "1": {
                            "name": "variable.other.readwrite.dm"
                        }
                    }
                }
            ]
        },
        "declaration-expression-local": {
            "match": "(?x) # e.g. int x OR var x\n(?:\n  \\b(var)\\b|\n  (?<type_name>\n    (?:\n      (?:\n        (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n        (?<name_and_type_args> # identifier + type arguments (if any)\n          \\g<identifier>\\s*\n          (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n        )\n        (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n      )\n      (?:\\s*\\?\\s*)? # nullable suffix?\n      (?:\\s* # array suffix?\n        \\[\n          (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n        \\]\n        \\s*\n        (?:\\?)? # arrays can be nullable reference types\n        \\s*\n      )*\n    )\n  )\n)\\s+\n(\\g<identifier>)\\b\\s*\n(?=[,)\\]])",
            "captures": {
                "1": {
                    "name": "storage.type.var.dm"
                },
                "2": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                },
                "7": {
                    "name": "entity.name.variable.local.dm"
                }
            }
        },
        "declaration-expression-tuple": {
            "match": "(?x) # e.g. int x OR var x\n(?:\n  \\b(var)\\b|\n  (?<type_name>\n    (?:\n      (?:\n        (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n        (?<name_and_type_args> # identifier + type arguments (if any)\n          \\g<identifier>\\s*\n          (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n        )\n        (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n      )\n      (?:\\s*\\?\\s*)? # nullable suffix?\n                (?:\\s* # array suffix?\n      \\[\n        (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n      \\]\n      \\s*\n      (?:\\?)? # arrays can be nullable reference types\n      \\s*\n    )*\n    )\n  )\n)\\s+\n(\\g<identifier>)\\b\\s*\n(?=[,)])",
            "captures": {
                "1": {
                    "name": "storage.type.var.dm"
                },
                "2": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                },
                "7": {
                    "name": "entity.name.variable.tuple-element.dm"
                }
            }
        },
        "expression-operator-expression": {
            "begin": "\\b(checked|unchecked|nameof)\\s*(\\()",
            "beginCaptures": {
                "1": {
                    "name": "keyword.operator.expression.$1.dm"
                },
                "2": {
                    "name": "punctuation.parenthesis.open.dm"
                }
            },
            "end": "\\)",
            "endCaptures": {
                "0": {
                    "name": "punctuation.parenthesis.close.dm"
                }
            },
            "patterns": [
                {
                    "include": "#expression"
                }
            ]
        },
        "type-operator-expression": {
            "begin": "\\b(default|sizeof|typeof)\\s*(\\()",
            "beginCaptures": {
                "1": {
                    "name": "keyword.operator.expression.$1.dm"
                },
                "2": {
                    "name": "punctuation.parenthesis.open.dm"
                }
            },
            "end": "\\)",
            "endCaptures": {
                "0": {
                    "name": "punctuation.parenthesis.close.dm"
                }
            },
            "patterns": [
                {
                    "include": "#type"
                }
            ]
        },
        "default-literal-expression": {
            "match": "\\b(default)\\b",
            "captures": {
                "1": {
                    "name": "keyword.operator.expression.default.dm"
                }
            }
        },
        "throw-expression": {
            "match": "\\b(throw)\\b",
            "captures": {
                "1": {
                    "name": "keyword.control.flow.throw.dm"
                }
            }
        },
        "interpolated-string": {
            "name": "string.quoted.double.dm",
            "begin": "\\$\"",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.definition.string.begin.dm"
                }
            },
            "end": "(\")|((?:[^\\\\\\n])$)",
            "endCaptures": {
                "1": {
                    "name": "punctuation.definition.string.end.dm"
                },
                "2": {
                    "name": "invalid.illegal.newline.dm"
                }
            },
            "patterns": [
                {
                    "include": "#string-character-escape"
                },
                {
                    "include": "#interpolation"
                }
            ]
        },
        "verbatim-interpolated-string": {
            "name": "string.quoted.double.dm",
            "begin": "(?:\\$@|@\\$)\"",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.definition.string.begin.dm"
                }
            },
            "end": "\"(?=[^\"])",
            "endCaptures": {
                "0": {
                    "name": "punctuation.definition.string.end.dm"
                }
            },
            "patterns": [
                {
                    "include": "#verbatim-string-character-escape"
                },
                {
                    "include": "#interpolation"
                }
            ]
        },
        "interpolation": {
            "name": "meta.interpolation.dm",
            "begin": "(?<=[^\\{]|^)((?:\\{\\{)*)(\\{)(?=[^\\{])",
            "beginCaptures": {
                "1": {
                    "name": "string.quoted.double.dm"
                },
                "2": {
                    "name": "punctuation.definition.interpolation.begin.dm"
                }
            },
            "end": "\\}",
            "endCaptures": {
                "0": {
                    "name": "punctuation.definition.interpolation.end.dm"
                }
            },
            "patterns": [
                {
                    "include": "#expression"
                }
            ]
        },
        "raw-interpolated-string": {
            "patterns": [
                {
                    "include": "#raw-interpolated-string-five-or-more-quote-one-or-more-interpolation"
                },
                {
                    "include": "#raw-interpolated-string-three-or-more-quote-three-or-more-interpolation"
                },
                {
                    "include": "#raw-interpolated-string-quadruple-quote-double-interpolation"
                },
                {
                    "include": "#raw-interpolated-string-quadruple-quote-single-interpolation"
                },
                {
                    "include": "#raw-interpolated-string-triple-quote-double-interpolation"
                },
                {
                    "include": "#raw-interpolated-string-triple-quote-single-interpolation"
                }
            ]
        },
        "raw-interpolated-string-triple-quote-single-interpolation": {
            "name": "string.quoted.double.dm",
            "begin": "\\$\"\"\"",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.definition.string.begin.dm"
                }
            },
            "end": "\"\"\"",
            "endCaptures": {
                "0": {
                    "name": "punctuation.definition.string.end.dm"
                }
            },
            "patterns": [
                {
                    "include": "#raw-interpolation"
                }
            ]
        },
        "raw-interpolated-string-triple-quote-double-interpolation": {
            "name": "string.quoted.double.dm",
            "begin": "\\$\\$\"\"\"",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.definition.string.begin.dm"
                }
            },
            "end": "\"\"\"",
            "endCaptures": {
                "0": {
                    "name": "punctuation.definition.string.end.dm"
                }
            },
            "patterns": [
                {
                    "include": "#double-raw-interpolation"
                }
            ]
        },
        "raw-interpolated-string-quadruple-quote-single-interpolation": {
            "name": "string.quoted.double.dm",
            "begin": "\\$\"\"\"\"",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.definition.string.begin.dm"
                }
            },
            "end": "\"\"\"\"",
            "endCaptures": {
                "0": {
                    "name": "punctuation.definition.string.end.dm"
                }
            },
            "patterns": [
                {
                    "include": "#raw-interpolation"
                }
            ]
        },
        "raw-interpolated-string-quadruple-quote-double-interpolation": {
            "name": "string.quoted.double.dm",
            "begin": "\\$\\$\"\"\"\"",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.definition.string.begin.dm"
                }
            },
            "end": "\"\"\"\"",
            "endCaptures": {
                "0": {
                    "name": "punctuation.definition.string.end.dm"
                }
            },
            "patterns": [
                {
                    "include": "#double-raw-interpolation"
                }
            ]
        },
        "raw-interpolated-string-three-or-more-quote-three-or-more-interpolation": {
            "name": "string.quoted.double.dm",
            "begin": "\\$\\$\\$+\"\"\"+",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.definition.string.begin.dm"
                }
            },
            "end": "\"\"\"+",
            "endCaptures": {
                "0": {
                    "name": "punctuation.definition.string.end.dm"
                }
            }
        },
        "raw-interpolated-string-five-or-more-quote-one-or-more-interpolation": {
            "name": "string.quoted.double.dm",
            "begin": "\\$+\"\"\"\"\"+",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.definition.string.begin.dm"
                }
            },
            "end": "\"\"\"\"\"+",
            "endCaptures": {
                "0": {
                    "name": "punctuation.definition.string.end.dm"
                }
            }
        },
        "raw-interpolation": {
            "name": "meta.interpolation.dm",
            "begin": "(?<=[^\\{]|^)((?:\\{)*)(\\{)(?=[^\\{])",
            "beginCaptures": {
                "1": {
                    "name": "string.quoted.double.dm"
                },
                "2": {
                    "name": "punctuation.definition.interpolation.begin.dm"
                }
            },
            "end": "\\}",
            "endCaptures": {
                "0": {
                    "name": "punctuation.definition.interpolation.end.dm"
                }
            },
            "patterns": [
                {
                    "include": "#expression"
                }
            ]
        },
        "double-raw-interpolation": {
            "name": "meta.interpolation.dm",
            "begin": "(?<=[^\\{][^\\{]|^)((?:\\{)*)(\\{\\{)(?=[^\\{])",
            "beginCaptures": {
                "1": {
                    "name": "string.quoted.double.dm"
                },
                "2": {
                    "name": "punctuation.definition.interpolation.begin.dm"
                }
            },
            "end": "\\}\\}",
            "endCaptures": {
                "0": {
                    "name": "punctuation.definition.interpolation.end.dm"
                }
            },
            "patterns": [
                {
                    "include": "#expression"
                }
            ]
        },
        "literal": {
            "patterns": [
                {
                    "include": "#boolean-literal"
                },
                {
                    "include": "#null-literal"
                },
                {
                    "include": "#numeric-literal"
                },
                {
                    "include": "#char-literal"
                },
                {
                    "include": "#raw-string-literal"
                },
                {
                    "include": "#string-literal"
                },
                {
                    "include": "#verbatim-string-literal"
                },
                {
                    "include": "#tuple-literal"
                }
            ]
        },
        "boolean-literal": {
            "patterns": [
                {
                    "name": "constant.language.boolean.true.dm",
                    "match": "(?<!\\.)\\btrue\\b"
                },
                {
                    "name": "constant.language.boolean.false.dm",
                    "match": "(?<!\\.)\\bfalse\\b"
                }
            ]
        },
        "null-literal": {
            "name": "constant.language.null.dm",
            "match": "(?<!\\.)\\bnull\\b"
        },
        "numeric-literal": {
            "match": "(?<!\\w)\\.?\\d(?:(?:[0-9a-zA-Z_]|_)|(?<=[eE])[+-]|\\.\\d)*",
            "captures": {
                "0": {
                    "patterns": [
                        {
                            "begin": "(?=.)",
                            "end": "$",
                            "patterns": [
                                {
                                    "match": "(\\G(?=[0-9.])(?!0[xXbB]))([0-9](?:[0-9]|((?<=[0-9a-fA-F])_(?=[0-9a-fA-F])))*)?((?:(?<=[0-9])|\\.(?=[0-9])))([0-9](?:[0-9]|((?<=[0-9a-fA-F])_(?=[0-9a-fA-F])))*)?((?<!_)([eE])(\\+?)(\\-?)((?:[0-9](?:[0-9]|(?:(?<=[0-9a-fA-F])_(?=[0-9a-fA-F])))*)))?([fFdDmM](?!\\w))?$",
                                    "captures": {
                                        "2": {
                                            "name": "constant.numeric.decimal.dm",
                                            "patterns": [
                                                {
                                                    "match": "(?<=[0-9a-fA-F])_(?=[0-9a-fA-F])",
                                                    "name": "constant.numeric.other.separator.thousands.dm"
                                                }
                                            ]
                                        },
                                        "3": {
                                            "name": "constant.numeric.other.separator.thousands.dm"
                                        },
                                        "4": {
                                            "name": "constant.numeric.other.separator.decimals.dm"
                                        },
                                        "5": {
                                            "name": "constant.numeric.decimal.dm",
                                            "patterns": [
                                                {
                                                    "match": "(?<=[0-9a-fA-F])_(?=[0-9a-fA-F])",
                                                    "name": "constant.numeric.other.separator.thousands.dm"
                                                }
                                            ]
                                        },
                                        "6": {
                                            "name": "constant.numeric.other.separator.thousands.dm"
                                        },
                                        "8": {
                                            "name": "constant.numeric.other.exponent.dm"
                                        },
                                        "9": {
                                            "name": "keyword.operator.arithmetic.dm"
                                        },
                                        "10": {
                                            "name": "keyword.operator.arithmetic.dm"
                                        },
                                        "11": {
                                            "name": "constant.numeric.decimal.dm",
                                            "patterns": [
                                                {
                                                    "match": "(?<=[0-9a-fA-F])_(?=[0-9a-fA-F])",
                                                    "name": "constant.numeric.other.separator.thousands.dm"
                                                }
                                            ]
                                        },
                                        "12": {
                                            "name": "constant.numeric.other.suffix.dm"
                                        }
                                    }
                                },
                                {
                                    "match": "(\\G0[bB])([01_](?:[01_]|((?<=[0-9a-fA-F])_(?=[0-9a-fA-F])))*)((?:(?:(?:(?:(?:[uU]|[uU]l)|[uU]L)|l[uU]?)|L[uU]?)|[fFdDmM])(?!\\w))?$",
                                    "captures": {
                                        "1": {
                                            "name": "constant.numeric.other.preffix.binary.dm"
                                        },
                                        "2": {
                                            "name": "constant.numeric.binary.dm",
                                            "patterns": [
                                                {
                                                    "match": "(?<=[0-9a-fA-F])_(?=[0-9a-fA-F])",
                                                    "name": "constant.numeric.other.separator.thousands.dm"
                                                }
                                            ]
                                        },
                                        "3": {
                                            "name": "constant.numeric.other.separator.thousands.dm"
                                        },
                                        "4": {
                                            "name": "constant.numeric.other.suffix.dm"
                                        }
                                    }
                                },
                                {
                                    "match": "(\\G0[xX])([0-9a-fA-F](?:[0-9a-fA-F]|((?<=[0-9a-fA-F])_(?=[0-9a-fA-F])))*)((?:(?:(?:(?:(?:[uU]|[uU]l)|[uU]L)|l[uU]?)|L[uU]?)|[fFdDmM])(?!\\w))?$",
                                    "captures": {
                                        "1": {
                                            "name": "constant.numeric.other.preffix.hex.dm"
                                        },
                                        "2": {
                                            "name": "constant.numeric.hex.dm",
                                            "patterns": [
                                                {
                                                    "match": "(?<=[0-9a-fA-F])_(?=[0-9a-fA-F])",
                                                    "name": "constant.numeric.other.separator.thousands.dm"
                                                }
                                            ]
                                        },
                                        "3": {
                                            "name": "constant.numeric.other.separator.thousands.dm"
                                        },
                                        "4": {
                                            "name": "constant.numeric.other.suffix.dm"
                                        }
                                    }
                                },
                                {
                                    "match": "(\\G(?=[0-9.])(?!0[xXbB]))([0-9](?:[0-9]|((?<=[0-9a-fA-F])_(?=[0-9a-fA-F])))*)((?<!_)([eE])(\\+?)(\\-?)((?:[0-9](?:[0-9]|(?:(?<=[0-9a-fA-F])_(?=[0-9a-fA-F])))*)))?((?:(?:(?:(?:(?:[uU]|[uU]l)|[uU]L)|l[uU]?)|L[uU]?)|[fFdDmM])(?!\\w))?$",
                                    "captures": {
                                        "2": {
                                            "name": "constant.numeric.decimal.dm",
                                            "patterns": [
                                                {
                                                    "match": "(?<=[0-9a-fA-F])_(?=[0-9a-fA-F])",
                                                    "name": "constant.numeric.other.separator.thousands.dm"
                                                }
                                            ]
                                        },
                                        "3": {
                                            "name": "constant.numeric.other.separator.thousands.dm"
                                        },
                                        "5": {
                                            "name": "constant.numeric.other.exponent.dm"
                                        },
                                        "6": {
                                            "name": "keyword.operator.arithmetic.dm"
                                        },
                                        "7": {
                                            "name": "keyword.operator.arithmetic.dm"
                                        },
                                        "8": {
                                            "name": "constant.numeric.decimal.dm",
                                            "patterns": [
                                                {
                                                    "match": "(?<=[0-9a-fA-F])_(?=[0-9a-fA-F])",
                                                    "name": "constant.numeric.other.separator.thousands.dm"
                                                }
                                            ]
                                        },
                                        "9": {
                                            "name": "constant.numeric.other.suffix.dm"
                                        }
                                    }
                                },
                                {
                                    "match": "(?:(?:[0-9a-zA-Z_]|_)|(?<=[eE])[+-]|\\.\\d)+",
                                    "name": "invalid.illegal.constant.numeric.dm"
                                }
                            ]
                        }
                    ]
                }
            }
        },
        "char-literal": {
            "name": "string.quoted.single.dm",
            "begin": "'",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.definition.char.begin.dm"
                }
            },
            "end": "(\\')|((?:[^\\\\\\n])$)",
            "endCaptures": {
                "1": {
                    "name": "punctuation.definition.char.end.dm"
                },
                "2": {
                    "name": "invalid.illegal.newline.dm"
                }
            },
            "patterns": [
                {
                    "include": "#char-character-escape"
                }
            ]
        },
        "char-character-escape": {
            "name": "constant.character.escape.dm",
            "match": "\\\\(['\"\\\\0abfnrtv]|x[0-9a-fA-F]{1,4}|u[0-9a-fA-F]{4})"
        },
        "string-literal": {
            "name": "string.quoted.double.dm",
            "begin": "(?<!@)\"",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.definition.string.begin.dm"
                }
            },
            "end": "(\")|((?:[^\\\\\\n])$)",
            "endCaptures": {
                "1": {
                    "name": "punctuation.definition.string.end.dm"
                },
                "2": {
                    "name": "invalid.illegal.newline.dm"
                }
            },
            "patterns": [
                {
                    "include": "#string-character-escape"
                }
            ]
        },
        "string-character-escape": {
            "name": "constant.character.escape.dm",
            "match": "\\\\(['\"\\\\0abfnrtv]|x[0-9a-fA-F]{1,4}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4})"
        },
        "verbatim-string-literal": {
            "name": "string.quoted.double.dm",
            "begin": "@\"",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.definition.string.begin.dm"
                }
            },
            "end": "\"(?=[^\"])",
            "endCaptures": {
                "0": {
                    "name": "punctuation.definition.string.end.dm"
                }
            },
            "patterns": [
                {
                    "include": "#verbatim-string-character-escape"
                }
            ]
        },
        "verbatim-string-character-escape": {
            "name": "constant.character.escape.dm",
            "match": "\"\""
        },
        "raw-string-literal": {
            "patterns": [
                {
                    "include": "#raw-string-literal-more"
                },
                {
                    "include": "#raw-string-literal-quadruple"
                },
                {
                    "include": "#raw-string-literal-triple"
                }
            ]
        },
        "raw-string-literal-triple": {
            "name": "string.quoted.double.dm",
            "begin": "\"\"\"",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.definition.string.begin.dm"
                }
            },
            "end": "\"\"\"",
            "endCaptures": {
                "0": {
                    "name": "punctuation.definition.string.end.dm"
                }
            }
        },
        "raw-string-literal-quadruple": {
            "name": "string.quoted.double.dm",
            "begin": "\"\"\"\"",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.definition.string.begin.dm"
                }
            },
            "end": "\"\"\"\"",
            "endCaptures": {
                "0": {
                    "name": "punctuation.definition.string.end.dm"
                }
            }
        },
        "raw-string-literal-more": {
            "name": "string.quoted.double.dm",
            "begin": "\"\"\"\"\"+",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.definition.string.begin.dm"
                }
            },
            "end": "\"\"\"\"\"+",
            "endCaptures": {
                "0": {
                    "name": "punctuation.definition.string.end.dm"
                }
            }
        },
        "tuple-literal": {
            "begin": "(\\()(?=.*[:,])",
            "beginCaptures": {
                "1": {
                    "name": "punctuation.parenthesis.open.dm"
                }
            },
            "end": "\\)",
            "endCaptures": {
                "0": {
                    "name": "punctuation.parenthesis.close.dm"
                }
            },
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#tuple-literal-element"
                },
                {
                    "include": "#expression"
                },
                {
                    "include": "#punctuation-comma"
                }
            ]
        },
        "tuple-literal-element": {
            "begin": "(?x)\n(@?[_[:alpha:]][_[:alnum:]]*)\\s*\n(?=:)",
            "beginCaptures": {
                "1": {
                    "name": "entity.name.variable.tuple-element.dm"
                }
            },
            "end": "(:)",
            "endCaptures": {
                "0": {
                    "name": "punctuation.separator.colon.dm"
                }
            }
        },
        "assignment-expression": {
            "begin": "(?:\\*|/|%|\\+|-|\\?\\?|\\&|\\^|<<|>>>?|\\|)?=(?!=|>)",
            "beginCaptures": {
                "0": {
                    "patterns": [
                        {
                            "include": "#assignment-operators"
                        }
                    ]
                }
            },
            "end": "(?=[,\\)\\];}])",
            "patterns": [
                {
                    "include": "#ref-modifier"
                },
                {
                    "include": "#expression"
                }
            ]
        },
        "assignment-operators": {
            "patterns": [
                {
                    "name": "keyword.operator.assignment.compound.dm",
                    "match": "\\*=|/=|%=|\\+=|-=|\\?\\?="
                },
                {
                    "name": "keyword.operator.assignment.compound.bitwise.dm",
                    "match": "\\&=|\\^=|<<=|>>>?=|\\|="
                },
                {
                    "name": "keyword.operator.assignment.dm",
                    "match": "\\="
                }
            ]
        },
        "expression-operators": {
            "patterns": [
                {
                    "name": "keyword.operator.bitwise.shift.dm",
                    "match": "<<|>>>?"
                },
                {
                    "name": "keyword.operator.comparison.dm",
                    "match": "==|!="
                },
                {
                    "name": "keyword.operator.relational.dm",
                    "match": "<=|>=|<|>"
                },
                {
                    "name": "keyword.operator.logical.dm",
                    "match": "\\!|&&|\\|\\|"
                },
                {
                    "name": "keyword.operator.bitwise.dm",
                    "match": "\\&|~|\\^|\\|"
                },
                {
                    "name": "keyword.operator.decrement.dm",
                    "match": "--"
                },
                {
                    "name": "keyword.operator.increment.dm",
                    "match": "\\+\\+"
                },
                {
                    "name": "keyword.operator.arithmetic.dm",
                    "match": "\\+|-(?!>)|\\*|/|%"
                },
                {
                    "name": "keyword.operator.null-coalescing.dm",
                    "match": "\\?\\?"
                },
                {
                    "name": "keyword.operator.range.dm",
                    "match": "\\.\\."
                }
            ]
        },
        "with-expression": {
            "begin": "(?<!\\.)\\b(with)\\b\\s*(?=\\{|//|/\\*|$)",
            "beginCaptures": {
                "1": {
                    "name": "keyword.operator.expression.with.dm"
                }
            },
            "end": "(?<=\\})",
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#initializer-expression"
                }
            ]
        },
        "conditional-operator": {
            "patterns": [
                {
                    "name": "keyword.operator.conditional.question-mark.dm",
                    "match": "\\?(?!\\?|\\s*[.\\[])"
                },
                {
                    "name": "keyword.operator.conditional.colon.dm",
                    "match": ":"
                }
            ]
        },
        "await-expression": {
            "name": "keyword.operator.expression.await.dm",
            "match": "(?<!\\.\\s*)\\b(await)\\b"
        },
        "parenthesized-expression": {
            "begin": "\\(",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.parenthesis.open.dm"
                }
            },
            "end": "\\)",
            "endCaptures": {
                "0": {
                    "name": "punctuation.parenthesis.close.dm"
                }
            },
            "patterns": [
                {
                    "include": "#expression"
                }
            ]
        },
        "initializer-expression": {
            "begin": "\\{",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.curlybrace.open.dm"
                }
            },
            "end": "\\}",
            "endCaptures": {
                "0": {
                    "name": "punctuation.curlybrace.close.dm"
                }
            },
            "patterns": [
                {
                    "include": "#expression"
                },
                {
                    "include": "#punctuation-comma"
                }
            ]
        },
        "identifier": {
            "name": "variable.other.readwrite.dm",
            "match": "@?[_[:alpha:]][_[:alnum:]]*"
        },
        "cast-expression": {
            "match": "(?x)\n(\\()\\s*\n(?<type_name>\n  (?:\n    (?:\n      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name_and_type_args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s* # array suffix?\n      \\[\n        (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n      \\]\n      \\s*\n      (?:\\?)? # arrays can be nullable reference types\n      \\s*\n    )*\n  )\n)\\s*\n(\\))(?=\\s*-*!*@?[_[:alnum:]\\(])",
            "captures": {
                "1": {
                    "name": "punctuation.parenthesis.open.dm"
                },
                "2": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                },
                "7": {
                    "name": "punctuation.parenthesis.close.dm"
                }
            }
        },
        "as-expression": {
            "match": "(?x)\n(?<!\\.)\\b(as)\\b\\s*\n(?<type_name>\n  (?:\n    (?:\n      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name_and_type_args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\?(?!\\?))? # nullable suffix?\n    (?:\\s* # array suffix?\n      \\[\n        \\s*(?:,\\s*)* # commata for multi-dimensional arrays\n      \\]\n      (?:\\s*\\?(?!\\?))? # arrays can be nullable reference types\n    )*\n  )\n)?",
            "captures": {
                "1": {
                    "name": "keyword.operator.expression.as.dm"
                },
                "2": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                }
            }
        },
        "language-variable": {
            "patterns": [
                {
                    "name": "variable.language.$1.dm",
                    "match": "\\b(base|this)\\b"
                },
                {
                    "name": "variable.other.$1.dm",
                    "match": "\\b(value)\\b"
                }
            ]
        },
        "invocation-expression": {
            "begin": "(?x)\n(?:\n  (?:(\\?)\\s*)?                                    # preceding null-conditional operator?\n  (\\.)\\s*|                                        # preceding dot?\n  (->)\\s*                                         # preceding pointer arrow?\n)?\n(@?[_[:alpha:]][_[:alnum:]]*)\\s*                  # method name\n(\n  <\n  (?<type_args>\n    [^<>()]+|\n    <\\g<type_args>+>|\n    \\(\\g<type_args>+\\)\n  )+\n  >\\s*\n)?                                                # type arguments\n(?=\\()                                            # open paren of argument list",
            "beginCaptures": {
                "1": {
                    "name": "keyword.operator.null-conditional.dm"
                },
                "2": {
                    "name": "punctuation.accessor.dm"
                },
                "3": {
                    "name": "punctuation.accessor.pointer.dm"
                },
                "4": {
                    "name": "entity.name.function.dm"
                },
                "5": {
                    "patterns": [
                        {
                            "include": "#type-arguments"
                        }
                    ]
                }
            },
            "end": "(?<=\\))",
            "patterns": [
                {
                    "include": "#argument-list"
                }
            ]
        },
        "element-access-expression": {
            "begin": "(?x)\n(?:\n  (?:(\\?)\\s*)?  # preceding null-conditional operator?\n  (\\.)\\s*|      # preceding dot?\n  (->)\\s*       # preceding pointer arrow?\n)?\n(?:(@?[_[:alpha:]][_[:alnum:]]*)\\s*)? # property name\n(?:(\\?)\\s*)?                        # null-conditional operator?\n(?=\\[)                              # open bracket of argument list",
            "beginCaptures": {
                "1": {
                    "name": "keyword.operator.null-conditional.dm"
                },
                "2": {
                    "name": "punctuation.accessor.dm"
                },
                "3": {
                    "name": "punctuation.accessor.pointer.dm"
                },
                "4": {
                    "name": "variable.other.object.property.dm"
                },
                "5": {
                    "name": "keyword.operator.null-conditional.dm"
                }
            },
            "end": "(?<=\\])(?!\\s*\\[)",
            "patterns": [
                {
                    "include": "#bracketed-argument-list"
                }
            ]
        },
        "member-access-expression": {
            "patterns": [
                {
                    "match": "(?x)\n(?:\n  (?:(\\?)\\s*)?                    # preceding null-conditional operator?\n  (\\.)\\s*|                        # preceding dot?\n  (->)\\s*                         # preceding pointer arrow?\n)\n(@?[_[:alpha:]][_[:alnum:]]*)\\s*  # property name\n(?![_[:alnum:]]|\\(|(\\?)?\\[|<)     # next character is not alpha-numeric, nor a (, [, or <. Also, test for ?[",
                    "captures": {
                        "1": {
                            "name": "keyword.operator.null-conditional.dm"
                        },
                        "2": {
                            "name": "punctuation.accessor.dm"
                        },
                        "3": {
                            "name": "punctuation.accessor.pointer.dm"
                        },
                        "4": {
                            "name": "variable.other.object.property.dm"
                        }
                    }
                },
                {
                    "match": "(?x)\n(\\.)?\\s*\n(@?[_[:alpha:]][_[:alnum:]]*)\n(?<type_params>\\s*<([^<>]|\\g<type_params>)+>\\s*)\n(?=\n  (\\s*\\?)?\n  \\s*\\.\\s*@?[_[:alpha:]][_[:alnum:]]*\n)",
                    "captures": {
                        "1": {
                            "name": "punctuation.accessor.dm"
                        },
                        "2": {
                            "name": "variable.other.object.dm"
                        },
                        "3": {
                            "patterns": [
                                {
                                    "include": "#type-arguments"
                                }
                            ]
                        }
                    }
                },
                {
                    "match": "(?x)\n(@?[_[:alpha:]][_[:alnum:]]*)\n(?=\n  \\s*(?:(?:\\?\\s*)?\\.|->)\n  \\s*@?[_[:alpha:]][_[:alnum:]]*\n)",
                    "captures": {
                        "1": {
                            "name": "variable.other.object.dm"
                        }
                    }
                }
            ]
        },
        "object-creation-expression": {
            "patterns": [
                {
                    "include": "#object-creation-expression-with-parameters"
                },
                {
                    "include": "#object-creation-expression-with-no-parameters"
                }
            ]
        },
        "object-creation-expression-with-parameters": {
            "begin": "(?x)\n(new)(?:\\s+\n(?<type_name>\n  (?:\n    (?:\n      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name_and_type_args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s* # array suffix?\n      \\[\n        (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n      \\]\n      \\s*\n      (?:\\?)? # arrays can be nullable reference types\n      \\s*\n    )*\n  )\n))?\\s*\n(?=\\()",
            "beginCaptures": {
                "1": {
                    "name": "keyword.operator.expression.new.dm"
                },
                "2": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                }
            },
            "end": "(?<=\\))",
            "patterns": [
                {
                    "include": "#argument-list"
                }
            ]
        },
        "object-creation-expression-with-no-parameters": {
            "match": "(?x)\n(new)\\s+\n(?<type_name>\n  (?:\n    (?:\n      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name_and_type_args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s* # array suffix?\n      \\[\n        (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n      \\]\n      \\s*\n      (?:\\?)? # arrays can be nullable reference types\n      \\s*\n    )*\n  )\n)\\s*\n(?=\\{|//|/\\*|$)",
            "captures": {
                "1": {
                    "name": "keyword.operator.expression.new.dm"
                },
                "2": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                }
            }
        },
        "array-creation-expression": {
            "begin": "(?x)\n\\b(new|stackalloc)\\b\\s*\n(?<type_name>\n  (?:\n    (?:\n      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name_and_type_args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s* # array suffix?\n      \\[\n        (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n      \\]\n      \\s*\n      (?:\\?)? # arrays can be nullable reference types\n      \\s*\n    )*\n  )\n)?\\s*\n(?=\\[)",
            "beginCaptures": {
                "1": {
                    "name": "keyword.operator.expression.$1.dm"
                },
                "2": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                }
            },
            "end": "(?<=\\])",
            "patterns": [
                {
                    "include": "#bracketed-argument-list"
                }
            ]
        },
        "anonymous-object-creation-expression": {
            "begin": "\\b(new)\\b\\s*(?=\\{|//|/\\*|$)",
            "beginCaptures": {
                "1": {
                    "name": "keyword.operator.expression.new.dm"
                }
            },
            "end": "(?<=\\})",
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#initializer-expression"
                }
            ]
        },
        "bracketed-parameter-list": {
            "begin": "(?=(\\[))",
            "beginCaptures": {
                "1": {
                    "name": "punctuation.squarebracket.open.dm"
                }
            },
            "end": "(?=(\\]))",
            "endCaptures": {
                "1": {
                    "name": "punctuation.squarebracket.close.dm"
                }
            },
            "patterns": [
                {
                    "begin": "(?<=\\[)",
                    "end": "(?=\\])",
                    "patterns": [
                        {
                            "include": "#comment"
                        },
                        {
                            "include": "#attribute-section"
                        },
                        {
                            "include": "#parameter"
                        },
                        {
                            "include": "#punctuation-comma"
                        },
                        {
                            "include": "#variable-initializer"
                        }
                    ]
                }
            ]
        },
        "parenthesized-parameter-list": {
            "begin": "(\\()",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.parenthesis.open.dm"
                }
            },
            "end": "(\\))",
            "endCaptures": {
                "0": {
                    "name": "punctuation.parenthesis.close.dm"
                }
            },
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#attribute-section"
                },
                {
                    "include": "#parameter"
                },
                {
                    "include": "#punctuation-comma"
                },
                {
                    "include": "#variable-initializer"
                }
            ]
        },
        "parameter": {
            "match": "(?x)\n(?:(?:\\b(ref|params|out|in|this)\\b)\\s+)?\n(?<type_name>\n  (?:\n    (?:ref\\s+)?   # ref return\n    (?:\n      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name_and_type_args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^()]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s* # array suffix?\n      \\[\n        (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n      \\]\n      \\s*\n      (?:\\?)? # arrays can be nullable reference types\n      \\s*\n    )*\n  )\n)\\s+\n(\\g<identifier>)",
            "captures": {
                "1": {
                    "name": "storage.modifier.$1.dm"
                },
                "2": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                },
                "7": {
                    "name": "entity.name.variable.parameter.dm"
                }
            }
        },
        "argument-list": {
            "begin": "\\(",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.parenthesis.open.dm"
                }
            },
            "end": "\\)",
            "endCaptures": {
                "0": {
                    "name": "punctuation.parenthesis.close.dm"
                }
            },
            "patterns": [
                {
                    "include": "#named-argument"
                },
                {
                    "include": "#argument"
                },
                {
                    "include": "#punctuation-comma"
                }
            ]
        },
        "bracketed-argument-list": {
            "begin": "\\[",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.squarebracket.open.dm"
                }
            },
            "end": "\\]",
            "endCaptures": {
                "0": {
                    "name": "punctuation.squarebracket.close.dm"
                }
            },
            "patterns": [
                {
                    "include": "#named-argument"
                },
                {
                    "include": "#argument"
                },
                {
                    "include": "#punctuation-comma"
                }
            ]
        },
        "named-argument": {
            "begin": "(@?[_[:alpha:]][_[:alnum:]]*)\\s*(:)",
            "beginCaptures": {
                "1": {
                    "name": "entity.name.variable.parameter.dm"
                },
                "2": {
                    "name": "punctuation.separator.colon.dm"
                }
            },
            "end": "(?=(,|\\)|\\]))",
            "patterns": [
                {
                    "include": "#argument"
                }
            ]
        },
        "argument": {
            "patterns": [
                {
                    "name": "storage.modifier.$1.dm",
                    "match": "\\b(ref|in)\\b"
                },
                {
                    "begin": "\\b(out)\\b",
                    "beginCaptures": {
                        "1": {
                            "name": "storage.modifier.out.dm"
                        }
                    },
                    "end": "(?=,|\\)|\\])",
                    "patterns": [
                        {
                            "include": "#declaration-expression-local"
                        },
                        {
                            "include": "#expression"
                        }
                    ]
                },
                {
                    "include": "#expression"
                }
            ]
        },
        "query-expression": {
            "begin": "(?x)\n\\b(from)\\b\\s*\n(?<type_name>\n  (?:\n    (?:\n      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name_and_type_args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s* # array suffix?\n      \\[\n        (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n      \\]\n      \\s*\n      (?:\\?)? # arrays can be nullable reference types\n      \\s*\n    )*\n  )\n)?\n\\s+(\\g<identifier>)\\b\\s*\n\\b(in)\\b\\s*",
            "beginCaptures": {
                "1": {
                    "name": "keyword.operator.expression.query.from.dm"
                },
                "2": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                },
                "7": {
                    "name": "entity.name.variable.range-variable.dm"
                },
                "8": {
                    "name": "keyword.operator.expression.query.in.dm"
                }
            },
            "end": "(?=;|\\))",
            "patterns": [
                {
                    "include": "#query-body"
                },
                {
                    "include": "#expression"
                }
            ]
        },
        "query-body": {
            "patterns": [
                {
                    "include": "#let-clause"
                },
                {
                    "include": "#where-clause"
                },
                {
                    "include": "#join-clause"
                },
                {
                    "include": "#orderby-clause"
                },
                {
                    "include": "#select-clause"
                },
                {
                    "include": "#group-clause"
                }
            ]
        },
        "let-clause": {
            "begin": "(?x)\n\\b(let)\\b\\s*\n(@?[_[:alpha:]][_[:alnum:]]*)\\b\\s*\n(=)\\s*",
            "beginCaptures": {
                "1": {
                    "name": "keyword.operator.expression.query.let.dm"
                },
                "2": {
                    "name": "entity.name.variable.range-variable.dm"
                },
                "3": {
                    "name": "keyword.operator.assignment.dm"
                }
            },
            "end": "(?=;|\\))",
            "patterns": [
                {
                    "include": "#query-body"
                },
                {
                    "include": "#expression"
                }
            ]
        },
        "where-clause": {
            "begin": "(?x)\n\\b(where)\\b\\s*",
            "beginCaptures": {
                "1": {
                    "name": "keyword.operator.expression.query.where.dm"
                }
            },
            "end": "(?=;|\\))",
            "patterns": [
                {
                    "include": "#query-body"
                },
                {
                    "include": "#expression"
                }
            ]
        },
        "join-clause": {
            "begin": "(?x)\n\\b(join)\\b\\s*\n(?<type_name>\n  (?:\n    (?:\n      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name_and_type_args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s* # array suffix?\n      \\[\n        (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n      \\]\n      \\s*\n      (?:\\?)? # arrays can be nullable reference types\n      \\s*\n    )*\n  )\n)?\n\\s+(\\g<identifier>)\\b\\s*\n\\b(in)\\b\\s*",
            "beginCaptures": {
                "1": {
                    "name": "keyword.operator.expression.query.join.dm"
                },
                "2": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                },
                "7": {
                    "name": "entity.name.variable.range-variable.dm"
                },
                "8": {
                    "name": "keyword.operator.expression.query.in.dm"
                }
            },
            "end": "(?=;|\\))",
            "patterns": [
                {
                    "include": "#join-on"
                },
                {
                    "include": "#join-equals"
                },
                {
                    "include": "#join-into"
                },
                {
                    "include": "#query-body"
                },
                {
                    "include": "#expression"
                }
            ]
        },
        "join-on": {
            "match": "\\b(on)\\b\\s*",
            "captures": {
                "1": {
                    "name": "keyword.operator.expression.query.on.dm"
                }
            }
        },
        "join-equals": {
            "match": "\\b(equals)\\b\\s*",
            "captures": {
                "1": {
                    "name": "keyword.operator.expression.query.equals.dm"
                }
            }
        },
        "join-into": {
            "match": "(?x)\n\\b(into)\\b\\s*\n(@?[_[:alpha:]][_[:alnum:]]*)\\b\\s*",
            "captures": {
                "1": {
                    "name": "keyword.operator.expression.query.into.dm"
                },
                "2": {
                    "name": "entity.name.variable.range-variable.dm"
                }
            }
        },
        "orderby-clause": {
            "begin": "\\b(orderby)\\b\\s*",
            "beginCaptures": {
                "1": {
                    "name": "keyword.operator.expression.query.orderby.dm"
                }
            },
            "end": "(?=;|\\))",
            "patterns": [
                {
                    "include": "#ordering-direction"
                },
                {
                    "include": "#query-body"
                },
                {
                    "include": "#expression"
                },
                {
                    "include": "#punctuation-comma"
                }
            ]
        },
        "ordering-direction": {
            "match": "\\b(ascending|descending)\\b",
            "captures": {
                "1": {
                    "name": "keyword.operator.expression.query.$1.dm"
                }
            }
        },
        "select-clause": {
            "begin": "\\b(select)\\b\\s*",
            "beginCaptures": {
                "1": {
                    "name": "keyword.operator.expression.query.select.dm"
                }
            },
            "end": "(?=;|\\))",
            "patterns": [
                {
                    "include": "#query-body"
                },
                {
                    "include": "#expression"
                }
            ]
        },
        "group-clause": {
            "begin": "\\b(group)\\b\\s*",
            "beginCaptures": {
                "1": {
                    "name": "keyword.operator.expression.query.group.dm"
                }
            },
            "end": "(?=;|\\))",
            "patterns": [
                {
                    "include": "#group-by"
                },
                {
                    "include": "#group-into"
                },
                {
                    "include": "#query-body"
                },
                {
                    "include": "#expression"
                }
            ]
        },
        "group-by": {
            "match": "\\b(by)\\b\\s*",
            "captures": {
                "1": {
                    "name": "keyword.operator.expression.query.by.dm"
                }
            }
        },
        "group-into": {
            "match": "(?x)\n\\b(into)\\b\\s*\n(@?[_[:alpha:]][_[:alnum:]]*)\\b\\s*",
            "captures": {
                "1": {
                    "name": "keyword.operator.expression.query.into.dm"
                },
                "2": {
                    "name": "entity.name.variable.range-variable.dm"
                }
            }
        },
        "anonymous-method-expression": {
            "patterns": [
                {
                    "begin": "(?x)\n((?:\\b(?:async|static)\\b\\s*)*)\n(?:\n  (@?[_[:alpha:]][_[:alnum:]]*)\\b|\n  (\\()\n    (?<tuple>(?:[^()]|\\(\\g<tuple>\\))*)\n  (\\))\n)\\s*\n(=>)",
                    "beginCaptures": {
                        "1": {
                            "patterns": [
                                {
                                    "match": "async|static",
                                    "name": "storage.modifier.$0.dm"
                                }
                            ]
                        },
                        "2": {
                            "name": "entity.name.variable.parameter.dm"
                        },
                        "3": {
                            "name": "punctuation.parenthesis.open.dm"
                        },
                        "4": {
                            "patterns": [
                                {
                                    "include": "#comment"
                                },
                                {
                                    "include": "#explicit-anonymous-function-parameter"
                                },
                                {
                                    "include": "#implicit-anonymous-function-parameter"
                                },
                                {
                                    "include": "#default-argument"
                                },
                                {
                                    "include": "#punctuation-comma"
                                }
                            ]
                        },
                        "5": {
                            "name": "punctuation.parenthesis.close.dm"
                        },
                        "6": {
                            "name": "keyword.operator.arrow.dm"
                        }
                    },
                    "end": "(?=[,;)}])",
                    "patterns": [
                        {
                            "include": "#intrusive"
                        },
                        {
                            "begin": "(?={)",
                            "end": "(?=[,;)}])",
                            "patterns": [
                                {
                                    "include": "#block"
                                },
                                {
                                    "include": "#intrusive"
                                }
                            ]
                        },
                        {
                            "begin": "\\b(ref)\\b|(?=\\S)",
                            "beginCaptures": {
                                "1": {
                                    "name": "storage.modifier.ref.dm"
                                }
                            },
                            "end": "(?=[,;)}])",
                            "patterns": [
                                {
                                    "include": "#expression"
                                }
                            ]
                        }
                    ]
                },
                {
                    "begin": "(?x)\n((?:\\b(?:async|static)\\b\\s*)*)\n\\b(delegate)\\b\\s*",
                    "beginCaptures": {
                        "1": {
                            "patterns": [
                                {
                                    "match": "async|static",
                                    "name": "storage.modifier.$0.dm"
                                }
                            ]
                        },
                        "2": {
                            "name": "storage.type.delegate.dm"
                        }
                    },
                    "end": "(?<=})|(?=[,;)}])",
                    "patterns": [
                        {
                            "include": "#intrusive"
                        },
                        {
                            "begin": "\\(",
                            "beginCaptures": {
                                "0": {
                                    "name": "punctuation.parenthesis.open.dm"
                                }
                            },
                            "end": "\\)",
                            "endCaptures": {
                                "0": {
                                    "name": "punctuation.parenthesis.close.dm"
                                }
                            },
                            "patterns": [
                                {
                                    "include": "#intrusive"
                                },
                                {
                                    "include": "#explicit-anonymous-function-parameter"
                                },
                                {
                                    "include": "#punctuation-comma"
                                }
                            ]
                        },
                        {
                            "include": "#block"
                        }
                    ]
                }
            ]
        },
        "explicit-anonymous-function-parameter": {
            "match": "(?x)\n(?:\\b(ref|params|out|in)\\b\\s*)?\n(?<type_name>\n  (?:\n    (?:\n      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name_and_type_args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type_args><(?:[^<>]|\\g<type_args>)*>\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^()]|\\g<tuple>)*\\))\n    )\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s* # array suffix?\n      \\[\n        (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n      \\]\n      \\s*\n      (?:\\?)? # arrays can be nullable reference types\n      \\s*\n    )*\n  )\n)\\s*\n\\b(\\g<identifier>)\\b",
            "captures": {
                "1": {
                    "name": "storage.modifier.$1.dm"
                },
                "2": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                },
                "7": {
                    "name": "entity.name.variable.parameter.dm"
                }
            }
        },
        "implicit-anonymous-function-parameter": {
            "match": "\\@?[_[:alpha:]][_[:alnum:]]*\\b",
            "name": "entity.name.variable.parameter.dm"
        },
        "default-argument": {
            "begin": "=",
            "beginCaptures": {
                "0": {
                    "name": "keyword.operator.assignment.dm"
                }
            },
            "end": "(?=,|\\))",
            "patterns": [
                {
                    "include": "#expression"
                }
            ]
        },
        "type": {
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#ref-modifier"
                },
                {
                    "include": "#readonly-modifier"
                },
                {
                    "include": "#tuple-type"
                },
                {
                    "include": "#type-builtin"
                },
                {
                    "include": "#type-name"
                },
                {
                    "include": "#type-arguments"
                },
                {
                    "include": "#type-array-suffix"
                },
                {
                    "include": "#type-nullable-suffix"
                },
                {
                    "include": "#type-pointer-suffix"
                }
            ]
        },
        "ref-modifier": {
            "name": "storage.modifier.ref.dm",
            "match": "\\bref\\b"
        },
        "readonly-modifier": {
            "name": "storage.modifier.readonly.dm",
            "match": "\\breadonly\\b"
        },
        "tuple-type": {
            "begin": "\\(",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.parenthesis.open.dm"
                }
            },
            "end": "\\)",
            "endCaptures": {
                "0": {
                    "name": "punctuation.parenthesis.close.dm"
                }
            },
            "patterns": [
                {
                    "include": "#tuple-element"
                },
                {
                    "include": "#punctuation-comma"
                }
            ]
        },
        "tuple-element": {
            "match": "(?x)\n(?<type_name>\n  (?:\n    (?:\n      (?:(?<identifier>@?[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name_and_type_args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type_args>\\s*<(?:[^<>]|\\g<type_args>)+>\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name_and_type_args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s* # array suffix?\n      \\[\n        (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n      \\]\n      \\s*\n      (?:\\?)? # arrays can be nullable reference types\n      \\s*\n    )*\n  )\n)\n(?:(?<tuple_name>\\g<identifier>)\\b)?",
            "captures": {
                "1": {
                    "patterns": [
                        {
                            "include": "#type"
                        }
                    ]
                },
                "6": {
                    "name": "entity.name.variable.tuple-element.dm"
                }
            }
        },
        "type-builtin": {
            "match": "\\b(bool|s?byte|u?short|n?u?int|u?long|float|double|decimal|char|string|object|void|dynamic)\\b",
            "captures": {
                "1": {
                    "name": "keyword.type.$1.dm"
                }
            }
        },
        "type-name": {
            "patterns": [
                {
                    "match": "(@?[_[:alpha:]][_[:alnum:]]*)\\s*(\\:\\:)",
                    "captures": {
                        "1": {
                            "name": "entity.name.type.alias.dm"
                        },
                        "2": {
                            "name": "punctuation.separator.coloncolon.dm"
                        }
                    }
                },
                {
                    "match": "(@?[_[:alpha:]][_[:alnum:]]*)\\s*(\\.)",
                    "captures": {
                        "1": {
                            "name": "entity.name.type.dm"
                        },
                        "2": {
                            "name": "punctuation.accessor.dm"
                        }
                    }
                },
                {
                    "match": "(\\.)\\s*(@?[_[:alpha:]][_[:alnum:]]*)",
                    "captures": {
                        "1": {
                            "name": "punctuation.accessor.dm"
                        },
                        "2": {
                            "name": "entity.name.type.dm"
                        }
                    }
                },
                {
                    "name": "entity.name.type.dm",
                    "match": "@?[_[:alpha:]][_[:alnum:]]*"
                }
            ]
        },
        "type-arguments": {
            "begin": "<",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.definition.typeparameters.begin.dm"
                }
            },
            "end": ">",
            "endCaptures": {
                "0": {
                    "name": "punctuation.definition.typeparameters.end.dm"
                }
            },
            "patterns": [
                {
                    "include": "#type"
                },
                {
                    "include": "#punctuation-comma"
                }
            ]
        },
        "type-array-suffix": {
            "begin": "\\[",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.squarebracket.open.dm"
                }
            },
            "end": "\\]",
            "endCaptures": {
                "0": {
                    "name": "punctuation.squarebracket.close.dm"
                }
            },
            "patterns": [
                {
                    "include": "#intrusive"
                },
                {
                    "include": "#punctuation-comma"
                }
            ]
        },
        "type-nullable-suffix": {
            "match": "\\?",
            "name": "punctuation.separator.question-mark.dm"
        },
        "type-pointer-suffix": {
            "match": "\\*",
            "name": "punctuation.separator.asterisk.dm"
        },
        "operator-assignment": {
            "name": "keyword.operator.assignment.dm",
            "match": "(?<!=|!)(=)(?!=)"
        },
        "punctuation-comma": {
            "name": "punctuation.separator.comma.dm",
            "match": ","
        },
        "punctuation-semicolon": {
            "name": "punctuation.terminator.statement.dm",
            "match": ";"
        },
        "punctuation-accessor": {
            "name": "punctuation.accessor.dm",
            "match": "\\."
        },
        "intrusive": {
            "patterns": [
                {
                    "include": "#preprocessor"
                },
                {
                    "include": "#comment"
                }
            ]
        },
        "preprocessor": {
            "name": "meta.preprocessor.dm",
            "begin": "^\\s*(\\#)\\s*",
            "beginCaptures": {
                "1": {
                    "name": "punctuation.separator.hash.dm"
                }
            },
            "end": "(?<=$)",
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#preprocessor-define-or-undef"
                },
                {
                    "include": "#preprocessor-if-or-elif"
                },
                {
                    "include": "#preprocessor-else-or-endif"
                },
                {
                    "include": "#preprocessor-warning-or-error"
                },
                {
                    "include": "#preprocessor-region"
                },
                {
                    "include": "#preprocessor-endregion"
                }
            ]
        },
        "preprocessor-define-or-undef": {
            "match": "\\b(?:(define)|(undef))\\b\\s*\\b([_[:alpha:]][_[:alnum:]]*)\\b",
            "captures": {
                "1": {
                    "name": "keyword.preprocessor.define.dm"
                },
                "2": {
                    "name": "keyword.preprocessor.undef.dm"
                },
                "3": {
                    "name": "entity.name.variable.preprocessor.symbol.dm"
                }
            }
        },
        "preprocessor-if-or-elif": {
            "begin": "\\b(?:(if)|(elif))\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.preprocessor.if.dm"
                },
                "2": {
                    "name": "keyword.preprocessor.elif.dm"
                }
            },
            "end": "(?=$)",
            "patterns": [
                {
                    "include": "#comment"
                },
                {
                    "include": "#preprocessor-expression"
                }
            ]
        },
        "preprocessor-else-or-endif": {
            "match": "\\b(?:(else)|(endif))\\b",
            "captures": {
                "1": {
                    "name": "keyword.preprocessor.else.dm"
                },
                "2": {
                    "name": "keyword.preprocessor.endif.dm"
                }
            }
        },
        "preprocessor-warning-or-error": {
            "match": "\\b(?:(warning)|(error))\\b\\s*(.*)(?=$)",
            "captures": {
                "1": {
                    "name": "keyword.preprocessor.warning.dm"
                },
                "2": {
                    "name": "keyword.preprocessor.error.dm"
                },
                "3": {
                    "name": "string.unquoted.preprocessor.message.dm"
                }
            }
        },
        "preprocessor-load": {
            "begin": "\\b(load)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.preprocessor.load.dm"
                }
            },
            "end": "(?=$)",
            "patterns": [
                {
                    "match": "\\\"[^\"]*\\\"",
                    "captures": {
                        "0": {
                            "name": "string.quoted.double.dm"
                        }
                    }
                }
            ]
        },
        "preprocessor-r": {
            "begin": "\\b(r)\\b",
            "beginCaptures": {
                "1": {
                    "name": "keyword.preprocessor.r.dm"
                }
            },
            "end": "(?=$)",
            "patterns": [
                {
                    "match": "\\\"[^\"]*\\\"",
                    "captures": {
                        "0": {
                            "name": "string.quoted.double.dm"
                        }
                    }
                }
            ]
        },
        "preprocessor-region": {
            "match": "\\b(region)\\b\\s*(.*)(?=$)",
            "captures": {
                "1": {
                    "name": "keyword.preprocessor.region.dm"
                },
                "2": {
                    "name": "string.unquoted.preprocessor.message.dm"
                }
            }
        },
        "preprocessor-endregion": {
            "match": "\\b(endregion)\\b",
            "captures": {
                "1": {
                    "name": "keyword.preprocessor.endregion.dm"
                }
            }
        },
        "preprocessor-expression": {
            "patterns": [
                {
                    "begin": "\\(",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.open.dm"
                        }
                    },
                    "end": "\\)",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.parenthesis.close.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#preprocessor-expression"
                        }
                    ]
                },
                {
                    "match": "\\b(?:(true)|(false)|([_[:alpha:]][_[:alnum:]]*))\\b",
                    "captures": {
                        "1": {
                            "name": "constant.language.boolean.true.dm"
                        },
                        "2": {
                            "name": "constant.language.boolean.false.dm"
                        },
                        "3": {
                            "name": "entity.name.variable.preprocessor.symbol.dm"
                        }
                    }
                },
                {
                    "match": "(==|!=)|(\\!|&&|\\|\\|)",
                    "captures": {
                        "1": {
                            "name": "keyword.operator.comparison.dm"
                        },
                        "2": {
                            "name": "keyword.operator.logical.dm"
                        }
                    }
                }
            ]
        },
        "comment": {
            "patterns": [
                {
                    "name": "comment.block.documentation.dm",
                    "begin": "(^\\s+)?(///)(?!/)",
                    "while": "^(\\s*)(///)(?!/)",
                    "captures": {
                        "1": {
                            "name": "punctuation.whitespace.comment.leading.dm"
                        },
                        "2": {
                            "name": "punctuation.definition.comment.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#xml-doc-comment"
                        }
                    ]
                },
                {
                    "name": "comment.block.documentation.dm",
                    "begin": "(^\\s+)?(/\\*\\*)(?!/)",
                    "end": "(^\\s+)?(\\*/)",
                    "captures": {
                        "1": {
                            "name": "punctuation.whitespace.comment.leading.dm"
                        },
                        "2": {
                            "name": "punctuation.definition.comment.dm"
                        }
                    },
                    "patterns": [
                        {
                            "begin": "\\G(?=(?~\\*/)$)",
                            "while": "^(\\s*+)(\\*(?!/))?(?=(?~\\*/)$)",
                            "whileCaptures": {
                                "1": {
                                    "name": "punctuation.whitespace.comment.leading.dm"
                                },
                                "2": {
                                    "name": "punctuation.definition.comment.dm"
                                }
                            },
                            "patterns": [
                                {
                                    "include": "#xml-doc-comment"
                                }
                            ]
                        },
                        {
                            "include": "#xml-doc-comment"
                        }
                    ]
                },
                {
                    "name": "comment.line.double-slash.dm",
                    "begin": "(^\\s+)?(//).*$",
                    "while": "^(\\s*)(//).*$",
                    "captures": {
                        "1": {
                            "name": "punctuation.whitespace.comment.leading.dm"
                        },
                        "2": {
                            "name": "punctuation.definition.comment.dm"
                        }
                    }
                },
                {
                    "name": "comment.block.dm",
                    "begin": "/\\*",
                    "end": "\\*/",
                    "captures": {
                        "0": {
                            "name": "punctuation.definition.comment.dm"
                        }
                    }
                }
            ]
        },
        "xml-doc-comment": {
            "patterns": [
                {
                    "include": "#xml-comment"
                },
                {
                    "include": "#xml-character-entity"
                },
                {
                    "include": "#xml-cdata"
                },
                {
                    "include": "#xml-tag"
                }
            ]
        },
        "xml-tag": {
            "name": "meta.tag.dm",
            "begin": "(?x)\n(</?)\n(\n  (?:\n    ([-_[:alnum:]]+)\n    (:)\n  )?\n  ([-_[:alnum:]]+)\n)",
            "beginCaptures": {
                "1": {
                    "name": "punctuation.definition.tag.dm"
                },
                "2": {
                    "name": "entity.name.tag.dm"
                },
                "3": {
                    "name": "entity.name.tag.namespace.dm"
                },
                "4": {
                    "name": "punctuation.separator.colon.dm"
                },
                "5": {
                    "name": "entity.name.tag.localname.dm"
                }
            },
            "end": "(/?>)",
            "endCaptures": {
                "1": {
                    "name": "punctuation.definition.tag.dm"
                }
            },
            "patterns": [
                {
                    "include": "#xml-attribute"
                }
            ]
        },
        "xml-attribute": {
            "patterns": [
                {
                    "match": "(?x)\n(?:^|\\s+)\n(\n  (?:\n    ([-_[:alnum:]]+)\n    (:)\n  )?\n  ([-_[:alnum:]]+)\n)\n(=)",
                    "captures": {
                        "1": {
                            "name": "entity.other.attribute-name.dm"
                        },
                        "2": {
                            "name": "entity.other.attribute-name.namespace.dm"
                        },
                        "3": {
                            "name": "punctuation.separator.colon.dm"
                        },
                        "4": {
                            "name": "entity.other.attribute-name.localname.dm"
                        },
                        "5": {
                            "name": "punctuation.separator.equals.dm"
                        }
                    }
                },
                {
                    "include": "#xml-string"
                }
            ]
        },
        "xml-cdata": {
            "name": "string.unquoted.cdata.dm",
            "begin": "<!\\[CDATA\\[",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.definition.string.begin.dm"
                }
            },
            "end": "\\]\\]>",
            "endCaptures": {
                "0": {
                    "name": "punctuation.definition.string.end.dm"
                }
            }
        },
        "xml-string": {
            "patterns": [
                {
                    "name": "string.quoted.single.dm",
                    "begin": "\\'",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.definition.string.begin.dm"
                        }
                    },
                    "end": "\\'",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.definition.string.end.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#xml-character-entity"
                        }
                    ]
                },
                {
                    "name": "string.quoted.double.dm",
                    "begin": "\\\"",
                    "beginCaptures": {
                        "0": {
                            "name": "punctuation.definition.string.begin.dm"
                        }
                    },
                    "end": "\\\"",
                    "endCaptures": {
                        "0": {
                            "name": "punctuation.definition.string.end.dm"
                        }
                    },
                    "patterns": [
                        {
                            "include": "#xml-character-entity"
                        }
                    ]
                }
            ]
        },
        "xml-character-entity": {
            "patterns": [
                {
                    "name": "constant.character.entity.dm",
                    "match": "(?x)\n(&)\n(\n  (?:[[:alpha:]:_][[:alnum:]:_.-]*)|\n  (?:\\#[[:digit:]]+)|\n  (?:\\#x[[:xdigit:]]+)\n)\n(;)",
                    "captures": {
                        "1": {
                            "name": "punctuation.definition.constant.dm"
                        },
                        "3": {
                            "name": "punctuation.definition.constant.dm"
                        }
                    }
                },
                {
                    "name": "invalid.illegal.bad-ampersand.dm",
                    "match": "&"
                }
            ]
        },
        "xml-comment": {
            "name": "comment.block.dm",
            "begin": "<!--",
            "beginCaptures": {
                "0": {
                    "name": "punctuation.definition.comment.dm"
                }
            },
            "end": "-->",
            "endCaptures": {
                "0": {
                    "name": "punctuation.definition.comment.dm"
                }
            }
        }
    }
}